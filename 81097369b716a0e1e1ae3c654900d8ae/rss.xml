<?xml version="1.0" encoding="utf-8"?><rss version="2.0"><channel><title>everystep</title><link>https://wxrss.reinject.top/81097369b716a0e1e1ae3c654900d8ae/</link><description>An RSS feed.</description><language>zh-cn</language><lastBuildDate>Sun, 01 Mar 2026 15:47:46 +0800</lastBuildDate><generator>wxrss -- https://github.com/0xlane/wxrss</generator><item><title>C++ 面试必考：const 的七种用法，你能说全吗？</title><link>http://mp.weixin.qq.com/s?__biz=MjM5NjAxMzk4NA==&amp;mid=2247497770&amp;idx=1&amp;sn=d1fe5a3f38ca25e78209a8036966b78d&amp;chksm=a7ec1e7b342f561e55e576196d55f705cc5a090fc8fecc651d7be6006b06eadc5dc87638362d&amp;scene=0&amp;xtrack=1#rd</link><description><![CDATA[面试的时候，"请你讲一下 C++ 里 const 关键字的用法"几乎和 static 一样高频。很多人的第一反应是"const 就是定义常量嘛"。没错，但这只是冰山一角。const 在 C++ 里渗透]]></description><author>everystep</author><pubDate>Fri, 27 Feb 2026 08:58:20 +0800</pubDate></item><item><title>static：C++ 里最容易答错的面试第一题</title><link>http://mp.weixin.qq.com/s?__biz=MjM5NjAxMzk4NA==&amp;mid=2247497766&amp;idx=1&amp;sn=46c9298de593e10234c1eb3ab6ad8c0e&amp;chksm=a71f2f04b59d3801f21b80f914a2a23e6327a878b0b58e3e6d9ea712ec4a8fb3dec8d3a75bfe&amp;scene=0&amp;xtrack=1#rd</link><description><![CDATA[面试的时候，"请你讲一下 C++ 里 static 关键字的用法"大概是出场率最高的基础题之一。它看起来简单——你在 C 语言里就见过它。但 static 这个词在 C++ 里至少有四种完全不同的含义]]></description><author>everystep</author><pubDate>Thu, 26 Feb 2026 08:40:19 +0800</pubDate></item><item><title>C++20 最实用的新特性，很多人还没用起来</title><link>http://mp.weixin.qq.com/s?__biz=MjM5NjAxMzk4NA==&amp;mid=2247497762&amp;idx=1&amp;sn=0dd62817cbf5c5d937cf3ea6ff74271e&amp;chksm=a70b0498993fc436d653ed13ed6f2e01e036568f710e29bfdf0a19c9eae731dc6195c50946ee&amp;scene=0&amp;xtrack=1#rd</link><description><![CDATA[写模板的时候，你大概有过这种体验。代码写完了，编译一下，屏幕上哗啦啦滚出几十行报错。你盯着看了半天，发现真正的问题其实就一句话——你传了个不该传的类型进去。但编译器不会直接告诉你"这个类型不行"。它会]]></description><author>everystep</author><pubDate>Wed, 25 Feb 2026 22:00:00 +0800</pubDate></item><item><title>老项目最怕“类型靠默契”：std::any 给了一个更稳的办法</title><link>http://mp.weixin.qq.com/s?__biz=MjM5NjAxMzk4NA==&amp;mid=2247497758&amp;idx=1&amp;sn=bdfb9fd4adb28484702ee5e26f0c3930&amp;chksm=a7beb75dceb1561d4460651e59caad928bf5b3a5d1846bf04725f9df7aa721f7451066f3cbf9&amp;scene=0&amp;xtrack=1#rd</link><description><![CDATA[最折磨人的，不是一上线就炸的 bug。是“偶尔炸一次”的 bug。同一段代码，在 A 机器能跑，在 B 机器崩。你翻日志，常常只剩一句：类型不对。当年大家怎么硬扛把时间拨回去。那会儿还没有 std::]]></description><author>everystep</author><pubDate>Sat, 14 Feb 2026 20:29:34 +0800</pubDate></item><item><title>一次 return 可能多做 1 次大拷贝？</title><link>http://mp.weixin.qq.com/s?__biz=MjM5NjAxMzk4NA==&amp;mid=2247497754&amp;idx=1&amp;sn=af0a6f48e25e2b37e4024054475ec6fe&amp;chksm=a7b0ad09df985d5b4ddb629b9ab48e828354bf9fa408fef028fa95a78b52bbae4275b8ed8fce&amp;scene=0&amp;xtrack=1#rd</link><description><![CDATA[那会儿我们写 C++。还不叫 C++11。还叫 C++03。大家对“拷贝构造”这件事。有一种很天真的信任。觉得它应该不贵。反正代码看起来很干净。直到某天线上延迟突然抬头。你才发现自己在热路径上复印东西]]></description><author>everystep</author><pubDate>Thu, 12 Feb 2026 07:00:00 +0800</pubDate></item><item><title>lambda 不是语法糖：它把“生命周期”这笔账摊在你面前</title><link>http://mp.weixin.qq.com/s?__biz=MjM5NjAxMzk4NA==&amp;mid=2247497754&amp;idx=2&amp;sn=abcc229d7cc2538b17ddb3336a3ab664&amp;chksm=a7d8107addd5eb705c46690e29cf0a2f5133a766f9424e039bcad00d9aa233b9f1cda83de3e9&amp;scene=0&amp;xtrack=1#rd</link><description><![CDATA[那几年，写 STL 算法像背咒语。你会在代码里看到 bind1st、bind2nd、mem_fun。像一串古老的法术名。懂的人很淡定。不懂的人会怀疑自己是不是学错了语言。当年的痛点其实很朴素。你只是想]]></description><author>everystep</author><pubDate>Thu, 12 Feb 2026 07:00:00 +0800</pubDate></item><item><title>写过线程但总心虚？从一次小事故聊 C++11 的内存模型与 atomic</title><link>http://mp.weixin.qq.com/s?__biz=MjM5NjAxMzk4NA==&amp;mid=2247497752&amp;idx=1&amp;sn=c66707724674fc3541a91be106a6a6b8&amp;chksm=a7ba6ffe072d5c5740fb9bcc76e8e4ebb2151f1980ac7c1823658d8cd3ed1063375e0c34670e&amp;scene=0&amp;xtrack=1#rd</link><description><![CDATA[并发里最吓人的东西。不是线程。也不是锁。是那句“当然”。“当然我先写 data。”“当然再写 ready。”“当然别人看到 ready，就能看到 data。”当年大家就是这么想的。因为单线程一直这么活]]></description><author>everystep</author><pubDate>Wed, 11 Feb 2026 07:00:00 +0800</pubDate></item><item><title>typedef 还行，但 using 更像人话</title><link>http://mp.weixin.qq.com/s?__biz=MjM5NjAxMzk4NA==&amp;mid=2247497752&amp;idx=2&amp;sn=a43058e8d7e66c3fa5690026de057b9a&amp;chksm=a7612845144293717df4a17c84f006d898c058889d073539f7fe32a948e380ecfca0ad9a07a7&amp;scene=0&amp;xtrack=1#rd</link><description><![CDATA[typedef 这东西。老。但它当年是救命的。那会儿你想写一点“通用代码”。类型名一长就失控。你以为自己在写程序。其实是在抄模板参数。typedef 就像一根救生绳。先把你从类型海里拽出来。然后你会更]]></description><author>everystep</author><pubDate>Wed, 11 Feb 2026 07:00:00 +0800</pubDate></item><item><title>位运算最阴的坑：你以为你在写“位”，其实你在写“谜语”</title><link>http://mp.weixin.qq.com/s?__biz=MjM5NjAxMzk4NA==&amp;mid=2247497750&amp;idx=1&amp;sn=de03fa2e95ac880fcfcf2db853167b37&amp;chksm=a70581c8575453d37c4e1055f8be7b54714232481f330e814433fa5795081ff2dde3bcd3b869&amp;scene=0&amp;xtrack=1#rd</link><description><![CDATA[很久以前。写 C 的年代。你想表达“某一位是 1”。文档上画的是一格一格的二进制。代码里却只能写十六进制。于是大家开始背。0x80 是第 7 位。0x40 是第 6 位。0x20 是第 5 位。背熟了]]></description><author>everystep</author><pubDate>Tue, 10 Feb 2026 07:00:00 +0800</pubDate></item><item><title>我对 C++11 线程库的理解：先把坑踩一遍再讲概念</title><link>http://mp.weixin.qq.com/s?__biz=MjM5NjAxMzk4NA==&amp;mid=2247497750&amp;idx=2&amp;sn=285828e1dbdb783017011d43be7ff393&amp;chksm=a7dce79a66f78f3293be72b46c009f7ce047f6df4a5a437fafd0e80e3060aa3a9f6add3cd7f8&amp;scene=0&amp;xtrack=1#rd</link><description><![CDATA[先说句不那么体面的真相。当年写线程。很多时候不是在写业务。是写“平台差异”。Linux 这套。Windows 那套。你写的是 void*。你传的是 void*。你 debug 的也是 void*。有些]]></description><author>everystep</author><pubDate>Tue, 10 Feb 2026 07:00:00 +0800</pubDate></item><item><title>编译期不是炫技，是止血：relaxed constexpr 把事故变成编译错误</title><link>http://mp.weixin.qq.com/s?__biz=MjM5NjAxMzk4NA==&amp;mid=2247497748&amp;idx=1&amp;sn=49daab17ffd320b8904cb9933c074da7&amp;chksm=a76ca4bde952b100b8d1d025b72766a0b10c4483f8869d53eb0b1afa61b66f1ffb60a77fb8d3&amp;scene=0&amp;xtrack=1#rd</link><description><![CDATA[C++11 刚落地那会儿。大家一边兴奋。一边心里发虚。兴奋是因为。终于能写点新东西了。发虚是因为。编译器跟不上。你写的代码。不一定能过。更烦的是。它就算过了。也可能在你看不见的地方“偷偷干活”。比如。]]></description><author>everystep</author><pubDate>Mon, 09 Feb 2026 23:01:39 +0800</pubDate></item><item><title>当年大家都在手搓 0..N-1：后来标准库把这招收编了</title><link>http://mp.weixin.qq.com/s?__biz=MjM5NjAxMzk4NA==&amp;mid=2247497748&amp;idx=2&amp;sn=08dd1766930f7bb89620970b11f653a3&amp;chksm=a7b5f5e2591fbdd5b1b19585f35994ffaba76456f8891eea84ee809f7bfc18c8114329745507&amp;scene=0&amp;xtrack=1#rd</link><description><![CDATA[那会儿是 2013 年。C++11 刚从标准里出来没多久。编译器们各自“支持一点点”。你在博客上刷到一句话。“可变参数模板很强。”你一激动。想把自己的小项目也写得像个库。结果写着写着就卡住了。不是不会]]></description><author>everystep</author><pubDate>Mon, 09 Feb 2026 23:01:39 +0800</pubDate></item><item><title>线上啪一下：你以为只是少写几个字，结果修出悬空指针</title><link>http://mp.weixin.qq.com/s?__biz=MjM5NjAxMzk4NA==&amp;mid=2247497746&amp;idx=1&amp;sn=9a5248f7a978bd87fbf1cfbed8ef4a27&amp;chksm=a7db2cf7236fc173b430d65a4542bc1c8b1db992fc1886125dceb761f9501b18c57dca29cb61&amp;scene=0&amp;xtrack=1#rd</link><description><![CDATA[C++11 刚出来那会儿。大家刚学会写模板。写得挺兴奋。直到你要给函数写返回类型。手就停住了。不是不会。是你突然发现。你得把同一个类型。写两遍。一遍在表达式里。一遍在签名里。而且还得保证。永远一致。这]]></description><author>everystep</author><pubDate>Thu, 05 Feb 2026 11:00:00 +0800</pubDate></item><item><title>auto 省下来的字，最后会让你加班</title><link>http://mp.weixin.qq.com/s?__biz=MjM5NjAxMzk4NA==&amp;mid=2247497746&amp;idx=2&amp;sn=22dacffaa0fe1dbf6230d0727a75bdf4&amp;chksm=a7c821b10defb73a74cb609fbb31f3483ebb0c1490ba92fc9e35d32db2dfcc560aa0b474fb7a&amp;scene=0&amp;xtrack=1#rd</link><description><![CDATA[很久以前。你写 C++。还没有 auto。返回类型就得老老实实写全。写 wrapper 的时候。最先累的是手。然后是眼睛。再然后。你开始想办法“少写点”。typedef。宏。还有一句自我安慰。“我知道]]></description><author>everystep</author><pubDate>Thu, 05 Feb 2026 11:00:00 +0800</pubDate></item><item><title>写 C++ 的人迟早会懂：时间最怕“看不见的单位”</title><link>http://mp.weixin.qq.com/s?__biz=MjM5NjAxMzk4NA==&amp;mid=2247497739&amp;idx=1&amp;sn=eb1c745de029277074f32ab9b4792e77&amp;chksm=a767e66a22bf85fe8e51e0893ea87d82d9a561e68aaedf88d4e39249c39da3f80053eb1d90a4&amp;scene=0&amp;xtrack=1#rd</link><description><![CDATA[我第一次被“时间单位”坑。很久以前。久到我还以为“超时”这种东西。只会发生在别人家。结果它找上门了。而且一点都不高级。就是单位写错。当年：时间单位靠人脑记在 C 的世界里。你写延时，常见就是这些。sl]]></description><author>everystep</author><pubDate>Wed, 04 Feb 2026 07:00:00 +0800</pubDate></item><item><title>宏把你拆成两个世界：用变量模板把它钉回去</title><link>http://mp.weixin.qq.com/s?__biz=MjM5NjAxMzk4NA==&amp;mid=2247497739&amp;idx=2&amp;sn=a38e4187b0b345cf28a0b44591895ec6&amp;chksm=a75eba4dabb6dc01f21e0e37fc4ae361eae7cc6c8133e42644faaac62fdd3f186643dafd26b1&amp;scene=0&amp;xtrack=1#rd</link><description><![CDATA[那会儿写 C++。标准还没给你太多“高级玩具”。但项目该写还是得写。我们会写一堆常量。配一堆平台。再配一堆开关。你以为你在写一个 MAX_BUF。其实你在写一场“预处理器赌博”。预处理器就是编译前那一]]></description><author>everystep</author><pubDate>Wed, 04 Feb 2026 07:00:00 +0800</pubDate></item><item><title>你以为 unique_ptr 戒了 new？其实只是换了个姿势</title><link>http://mp.weixin.qq.com/s?__biz=MjM5NjAxMzk4NA==&amp;mid=2247497737&amp;idx=1&amp;sn=66c0625da66551f7f146727ff90ab8f0&amp;chksm=a7fb6f3e287fa75e269a69b604d4cf84d0ae1c6fa050302f297db213957e9bcd07d28fd9512e&amp;scene=0&amp;xtrack=1#rd</link><description><![CDATA[那会儿 C++11 刚开始进团队。大家第一次认真聊起一句老话。“资源跟着对象走”。对象死了。资源也该跟着收回。听起来很美。但你把代码一翻。还全是 new。你会愣一下。这戒指戴上了。怎么手里还攥着前任送]]></description><author>everystep</author><pubDate>Tue, 03 Feb 2026 07:00:00 +0800</pubDate></item><item><title>当 tuple 像“没名字的 struct”：get&lt;T&gt; 才是真正的“字段名”</title><link>http://mp.weixin.qq.com/s?__biz=MjM5NjAxMzk4NA==&amp;mid=2247497737&amp;idx=2&amp;sn=ca84a88d31a0c990261dc6f30442994c&amp;chksm=a78be31b0d57e92127f09964dbcafc16cc7f18f25fdac3872c6c15c6de77b42bb83d7fb710c2&amp;scene=0&amp;xtrack=1#rd</link><description><![CDATA[你写 C。一个函数想多返回点东西。你就把指针塞进去。当年大家都这么干。也不是不行。就是有点别扭。指针一多。你会开始记不清。到底哪个是“耗时”。哪个是“状态码”。后来 Boost 先做了 tuple。B]]></description><author>everystep</author><pubDate>Tue, 03 Feb 2026 07:00:00 +0800</pubDate></item><item><title>RAII + if 初始化语句：把锁的寿命控制到 1 条语句里</title><link>http://mp.weixin.qq.com/s?__biz=MjM5NjAxMzk4NA==&amp;mid=2247497733&amp;idx=1&amp;sn=e00118ce0e9c6aa38563263307026999&amp;chksm=a76c066c01fe10135783d18e437e41843a8eb0fdf6af07afcab072a596fcd538f254b69eddaa&amp;scene=0&amp;xtrack=1#rd</link><description><![CDATA[我见过最离谱的一次线上事故。不是内存越界。不是死锁。是一个迭代器。它本来只该活在一个 if 里。结果它活到了后面。然后我在 debug 分支里顺手用了它。线上就啪一下。这篇文章不背语法。只把一件事讲透]]></description><author>everystep</author><pubDate>Sun, 01 Feb 2026 07:00:00 +0800</pubDate></item><item><title>模板分支从玄学到语句：C++17 给了你一条直路</title><link>http://mp.weixin.qq.com/s?__biz=MjM5NjAxMzk4NA==&amp;mid=2247497733&amp;idx=2&amp;sn=c1a939131617fdf240d5b2cb0d3d132e&amp;chksm=a7523deb380bb38305e90d430bb0ed0193e9ae9abaf043bc49ce05587e44e89dfa820d5fad68&amp;scene=0&amp;xtrack=1#rd</link><description><![CDATA[我曾经被模板报错骂过。不是一句两句。是整屏。滚动条都不敢拉到底。你盯着那一堆类型名。像在看一张坏掉的账单。然后你发现。自己只是想写一个“泛型打印”。先补三个词：编译期、实例化、替换失败刚学 C++ 的]]></description><author>everystep</author><pubDate>Sun, 01 Feb 2026 07:00:00 +0800</pubDate></item><item><title>variant / any / 虚函数 怎么选：别凭感觉，按边界条件来</title><link>http://mp.weixin.qq.com/s?__biz=MjM5NjAxMzk4NA==&amp;mid=2247497731&amp;idx=1&amp;sn=abce8c6bc2892e1a76ea60b3c58db0ab&amp;chksm=a718a89d04c46a00b673a2b4d6d8d0fcdae6705dd0b074bdb5508d0bb818a434b87c13ad6a26&amp;scene=0&amp;xtrack=1#rd</link><description><![CDATA[我见过一种挺烦的 bug。程序不崩。也不报警。输出看着还挺像回事。但你其实是在用一种类型的眼镜。去读另一种类型的内存。如果你只学过 C，这事多半发生在 union 上。如果你刚开始写 C++，第二次坑]]></description><author>everystep</author><pubDate>Sat, 31 Jan 2026 07:00:00 +0800</pubDate></item><item><title>C++17 CTAD：省掉尖括号之前，先搞清楚它怎么推</title><link>http://mp.weixin.qq.com/s?__biz=MjM5NjAxMzk4NA==&amp;mid=2247497731&amp;idx=2&amp;sn=dec746da9a869395e6d7db492facba96&amp;chksm=a74d588a8c20577a927c54f91511fc26a08ab36d9c9d5e17015be650c016aa69f44fe59240b0&amp;scene=0&amp;xtrack=1#rd</link><description><![CDATA[我第一次嫌 C++ 啰嗦。不是因为语法多。是因为我在写一段代码的时候。经常要把“同一个类型信息”写两遍。你刚学 C++ 的时候。大概率会卡在这里。因为你明明看得见右边的构造参数。却还要在左边再抄一次模]]></description><author>everystep</author><pubDate>Sat, 31 Jan 2026 07:00:00 +0800</pubDate></item><item><title>什么时候用 optional，什么时候该换 expected/variant</title><link>http://mp.weixin.qq.com/s?__biz=MjM5NjAxMzk4NA==&amp;mid=2247497729&amp;idx=1&amp;sn=e44ef9adbec8f6bb086f78af2ffb9f2a&amp;chksm=a77d5136dfeb29de66a92677ef5491b760d9e95d1abe692e42f6003f0ada163c9bd456b3967a&amp;scene=0&amp;xtrack=1#rd</link><description><![CDATA[我最怕那种返回值。它不报错。但它也没告诉你。“这次其实没拿到结果”。你接到的是一个看起来很正常的 int。或者一个看起来很正常的指针。你就照着往下写。一直写到上线。然后某个周五晚上。啪一下。当年：我们]]></description><author>everystep</author><pubDate>Fri, 30 Jan 2026 07:00:00 +0800</pubDate></item><item><title>别再模板递归了：C++17 一行把参数包‘吃掉’</title><link>http://mp.weixin.qq.com/s?__biz=MjM5NjAxMzk4NA==&amp;mid=2247497729&amp;idx=2&amp;sn=3560e2c78e127ff9c93e62c3959a5a4c&amp;chksm=a72cc2e3d26633d4a6c6fb8e3f9b42eb4cfce76df0dea09a1463256187522664106707272871&amp;scene=0&amp;xtrack=1#rd</link><description><![CDATA[我第一次真用上折叠表达式，是在写日志的时候。线上出了点事故。我得把一串变量一次性吐出来。在 C 里你会写 printf。但 C 的 ... 是运行时的。类型信息靠格式串兜着。格式串一写错，崩的就是你自]]></description><author>everystep</author><pubDate>Fri, 30 Jan 2026 07:00:00 +0800</pubDate></item><item><title>做 AI 绕不开的第一步：把文本切对了（BPE 入门但不浅）</title><link>http://mp.weixin.qq.com/s?__biz=MjM5NjAxMzk4NA==&amp;mid=2247497727&amp;idx=1&amp;sn=cde6243e8ff2e81d86226b101a27eb31&amp;chksm=a7406237f3f2336cc68fff974d039871c0d464f655d5c829d460f5391bb97e21aa710fafd786&amp;scene=0&amp;xtrack=1#rd</link><description><![CDATA[大模型看起来在“理解文字”。 但它真正处理的，从来都不是文字。你每一次发 Prompt、每一次多花的 Token、每一次上下文装不下、每一次速度变慢、每一次遇到莫名其妙的切分结果，背后都站着同一个角色]]></description><author>everystep</author><pubDate>Thu, 29 Jan 2026 07:00:00 +0800</pubDate></item><item><title>我只是想打个日志，怎么就开始不停构造 std::string 了？</title><link>http://mp.weixin.qq.com/s?__biz=MjM5NjAxMzk4NA==&amp;mid=2247497727&amp;idx=2&amp;sn=58be6efe32443886825920c9584d8794&amp;chksm=a7918c2d1efe5eb53f5acce182b65c7baf3e3f91a963ea97797e21c41ee80d0287b8830d92cb&amp;scene=0&amp;xtrack=1#rd</link><description><![CDATA[我以前写过一个日志函数。上线前我还挺得意：接口统一收 std::string，省心又安全。上线后就尴尬了。CPU 抬头，分配次数也抬头。profile 一看，热路径里一大块都在构造 std::stri]]></description><author>everystep</author><pubDate>Thu, 29 Jan 2026 07:00:00 +0800</pubDate></item><item><title>delete 真相曝光：原来 C++ 一直在“瞎删”</title><link>http://mp.weixin.qq.com/s?__biz=MjM5NjAxMzk4NA==&amp;mid=2247497696&amp;idx=1&amp;sn=6705b311c618629d0b5e3fd6cc7b9de4&amp;chksm=a7f9aeba56c11b5f16ea3a95ff0553a528980ad7df9e73a2892663c3f5614e54b1aa6ba07048&amp;scene=0&amp;xtrack=1#rd</link><description><![CDATA[早年的 C 世界里，内存更像一张借条。你借走一块。还的时候只还一个地址。不写大小。听起来很离谱？当年大家还真就这么干了，而且干得挺理直气壮。那些年，free 从来不问“你借了多少”在最早的 C 里，m]]></description><author>everystep</author><pubDate>Wed, 28 Jan 2026 07:00:00 +0800</pubDate></item><item><title>宏写到眼瞎的年代结束了：[[deprecated]] 把废弃这事标准化</title><link>http://mp.weixin.qq.com/s?__biz=MjM5NjAxMzk4NA==&amp;mid=2247497696&amp;idx=2&amp;sn=740f05b59eb00d86271d48cf393afb7c&amp;chksm=a74647772e20a663084e05d7817632b42f1f5865691506c6e75f29ad61540e15e593711ee89f&amp;scene=0&amp;xtrack=1#rd</link><description><![CDATA[很多年前。我们想“废弃一个函数”。第一反应就是删掉。但你删一次。就会有人跑来敲你。“我升级了库，项目编不过了。”更要命的是。那时候很多库就是一堆头文件。接口发出去。就像把螺丝刀借给全公司。你收不回。所]]></description><author>everystep</author><pubDate>Wed, 28 Jan 2026 07:00:00 +0800</pubDate></item><item><title>写模板像对骂？C++14：把模板藏到 lambda 背后</title><link>http://mp.weixin.qq.com/s?__biz=MjM5NjAxMzk4NA==&amp;mid=2247497694&amp;idx=1&amp;sn=ff62a9fdb4a98ee19342d71518fa3069&amp;chksm=a770dd9cf4985dfad4b4c6ac771e3e3e91617293daa11ba55256d11488821cf01ecd512fb387&amp;scene=0&amp;xtrack=1#rd</link><description><![CDATA[那会儿还没有 lambda。STL 刚进大家的工具箱。你第一次用上 std::sort 的时候。真的会觉得它很爽。然后它就问你一句。“按什么规则排？”你以为这问题很简单。结果你在代码库里多了一个新文件]]></description><author>everystep</author><pubDate>Tue, 27 Jan 2026 07:00:00 +0800</pubDate></item><item><title>写进去什么，读出来就变样？std::quoted 专治不服</title><link>http://mp.weixin.qq.com/s?__biz=MjM5NjAxMzk4NA==&amp;mid=2247497694&amp;idx=2&amp;sn=c510aee9e0c8bc5ea0a14d45eb0dcc34&amp;chksm=a70cea721b578647471cf3a36d5739471a9040246052fc7778f5dfee46eb786b325ea3141eaa&amp;scene=0&amp;xtrack=1#rd</link><description><![CDATA[那会儿日志就是纯文本。也没人会说什么“结构化”。我们写日志。就是往文件里塞一行文本。然后靠 grep、awk、一点耐心。把问题捞出来。看起来粗糙。但真能救命。直到某一天。你想把“用户输入”也写进去。你]]></description><author>everystep</author><pubDate>Tue, 27 Jan 2026 07:00:00 +0800</pubDate></item><item><title>我只是想拼个字符串，C++ 怎么给我算了个地址？</title><link>http://mp.weixin.qq.com/s?__biz=MjM5NjAxMzk4NA==&amp;mid=2247497692&amp;idx=1&amp;sn=d08be4e8c9cac987de8fe882492ee665&amp;chksm=a7581c72ec47ecb3ec379d96c717886f5ca0bc0d4d79d9dea465dad46228eb705d216b9f0bff&amp;scene=0&amp;xtrack=1#rd</link><description><![CDATA[那会儿还没有 C++14。很多人写 C++。说白了。就是在写 C。只是多了点 class。字符串也没变聪明。你眼里是“字符串”。它手里攥着的。常常只是一个地址。地址平时挺乖。你一拿它去做 +。它就开始]]></description><author>everystep</author><pubDate>Mon, 26 Jan 2026 07:00:00 +0800</pubDate></item><item><title>从 Boost 到标准库：::type 这套老传统怎么来的</title><link>http://mp.weixin.qq.com/s?__biz=MjM5NjAxMzk4NA==&amp;mid=2247497692&amp;idx=2&amp;sn=7fc922713736e9bc027545eb54292560&amp;chksm=a78cb1419007e992d5127a73931c759853aaf44d4f4e20ffddf81e781106b0911246d4b7abab&amp;scene=0&amp;xtrack=1#rd</link><description><![CDATA[那会儿 C++11 刚开始进项目。你第一次在代码里碰到 <type_traits>。不是在书上。是在发版前一晚。你本地一跑编译。它啪一下就挂了。报错里反复出现一个词。::type。你盯着它。像盯着一根]]></description><author>everystep</author><pubDate>Mon, 26 Jan 2026 07:00:00 +0800</pubDate></item><item><title>编译能过不代表命能活：C++11 lambda 的生命周期坑</title><link>http://mp.weixin.qq.com/s?__biz=MjM5NjAxMzk4NA==&amp;mid=2247497690&amp;idx=1&amp;sn=f46ddd9f012025b349b59e8e13e1b97c&amp;chksm=a7d14152f6d775ed325f210025251bf6ac28e9cc448a55f1d80590a44ca7186929f6ffe90cb0&amp;scene=0&amp;xtrack=1#rd</link><description><![CDATA[那几年。C++11 刚出来。很多人第一次用上 lambda。感觉像突然不用再写那坨“函数对象”了。回调顺手。异步也顺手。大家写得很嗨。直到某天凌晨。线上啪一下。core dump。你第一反应是线程。第]]></description><author>everystep</author><pubDate>Sun, 25 Jan 2026 07:00:00 +0800</pubDate></item><item><title>别再数 0 了：C++14 让 1&apos;000&apos;000 一眼看懂</title><link>http://mp.weixin.qq.com/s?__biz=MjM5NjAxMzk4NA==&amp;mid=2247497690&amp;idx=2&amp;sn=22a2943377ed85d9b2be7d2ddca471a6&amp;chksm=a7bab979072c470c6736c5a045cf96fff3d6f80178c27d7b39578e74380aa045003e1f9a9c0d&amp;scene=0&amp;xtrack=1#rd</link><description><![CDATA[那会儿我们写 C/C++。配置常常就写在源码里。数字也就跟着一起写进去。一长串。一坨 0。你当时不会把它当风险。毕竟它“只是个常量”。直到有一天。你少写了一个 0。线上啪一下。服务开始挨打。你盯着那一]]></description><author>everystep</author><pubDate>Sun, 25 Jan 2026 07:00:00 +0800</pubDate></item><item><title>三四个返回值的时候，我一般怎么写</title><link>http://mp.weixin.qq.com/s?__biz=MjM5NjAxMzk4NA==&amp;mid=2247497630&amp;idx=1&amp;sn=bed3d5b1e0a54638b0d900e75d22e9f0&amp;chksm=a79c37c849416fd9530a33b1bd0b21c8d83213efc400d2a490b8e2169c1ff6bf5805aa100c44&amp;scene=0&amp;xtrack=1#rd</link><description><![CDATA[你想“从函数里带回两个东西”。没有神兵利器。只有手工活。有人用引用。有人用指针。有人写一堆小结构体。还有人……开始写宏。你没听错。为了多返回值。真的有人写宏。当年没有 tuple 的日子那会儿还在 C]]></description><author>everystep</author><pubDate>Sat, 24 Jan 2026 07:00:00 +0800</pubDate></item><item><title>当年我们怎么写“任意参数”：以及 C++11 怎么把它变得靠谱</title><link>http://mp.weixin.qq.com/s?__biz=MjM5NjAxMzk4NA==&amp;mid=2247497630&amp;idx=2&amp;sn=347f7e2331849ad087472cceeeb8384b&amp;chksm=a7e31cee53eb0345a85d0909e3d0948e5b33ae8a19bd3b90976011e7d2bd429a4253d8f3e62d&amp;scene=0&amp;xtrack=1#rd</link><description><![CDATA[那会儿还没有 C++11。我们写的东西更像 “C with classes”。也就是在 C 上面糊一层 class。项目不大。但麻烦一点都不少。尤其是日志。你总想写一个函数。什么都能塞进去。参数多少都]]></description><author>everystep</author><pubDate>Sat, 24 Jan 2026 07:00:00 +0800</pubDate></item><item><title>别急着上正则：从历史到 std::regex 的几个关键点</title><link>http://mp.weixin.qq.com/s?__biz=MjM5NjAxMzk4NA==&amp;mid=2247497628&amp;idx=1&amp;sn=a56c6a1506bc1e68d1c5a0535652ef0d&amp;chksm=a79dcca7a2a01c5105c136c6cc87a30d9bcd07cef50ba51f3cf8a854806f3aaf71fa484ad079&amp;scene=0&amp;xtrack=1#rd</link><description><![CDATA[很久以前。C++ 里想“用正则”，并不是一句 #include 就完事。你要么去翻 POSIX 的 regex.h。要么拉个 PCRE。要么用 Boost。然后开始跟编译选项、链接、版本兼容吵架。最尴]]></description><author>everystep</author><pubDate>Fri, 23 Jan 2026 07:00:00 +0800</pubDate></item><item><title>随机这事，别再靠 rand() 碰运气</title><link>http://mp.weixin.qq.com/s?__biz=MjM5NjAxMzk4NA==&amp;mid=2247497628&amp;idx=2&amp;sn=17d718cd192d40d02256640c38263861&amp;chksm=a77ddda50bcd8a5a11d9b1f99534123186b6863f12cc7724ecbbe0158d764a50b273395a8510&amp;scene=0&amp;xtrack=1#rd</link><description><![CDATA[很久以前。你写 C。你想要“随机”。你只有一个按钮。rand()。它来自 C 标准库。一开始也没打算让你拿它写抽奖、分流、风控。更多时候。是小游戏。是模拟。是“差不多就行”。然后我们就真的把它当成“随]]></description><author>everystep</author><pubDate>Fri, 23 Jan 2026 07:00:00 +0800</pubDate></item><item><title>std::function 到底解决了什么问题</title><link>http://mp.weixin.qq.com/s?__biz=MjM5NjAxMzk4NA==&amp;mid=2247497626&amp;idx=1&amp;sn=a9e0b8fe9d97c26d1bf8eda88c65925f&amp;chksm=a7f0bdcdc0403eb6faa861593157bc8401671669bce0510cad8cd9859872b96061b0c6ccc721&amp;scene=0&amp;xtrack=1#rd</link><description><![CDATA[你写个小项目。代码不多。需求也不复杂。直到它上线。然后某天晚上。线上啪一下。你盯着日志发呆。崩在一个“回调”。你甚至没觉得自己写了什么高深东西。你只是。“想把一个能调用的东西传进去”。那些年，回调是怎]]></description><author>everystep</author><pubDate>Thu, 22 Jan 2026 07:00:00 +0800</pubDate></item><item><title>unordered_map / unordered_set：当年没得选时，我们怎么做</title><link>http://mp.weixin.qq.com/s?__biz=MjM5NjAxMzk4NA==&amp;mid=2247497626&amp;idx=2&amp;sn=e7e74a1f7c2ef9ccb9afd3aa9fa13850&amp;chksm=a7e5e281ebadaf7b04eb4ae19ae846e82cd4cf7e2d1a5a83c1bddc13ffdd0fa8f133809b9fd1&amp;scene=0&amp;xtrack=1#rd</link><description><![CDATA[那会儿你想要一张“用 key 快速查值”的表。标准库不给。只给你 std::map。要么你自己写一个。要么去翻各家编译器的私货。今天在你机器上能跑。明天换个编译器就报错。更惨的是。同事一更新工具链。线]]></description><author>everystep</author><pubDate>Thu, 22 Jan 2026 07:00:00 +0800</pubDate></item><item><title>智能指针这件事：从 new/delete 的坑里慢慢爬出来</title><link>http://mp.weixin.qq.com/s?__biz=MjM5NjAxMzk4NA==&amp;mid=2247497624&amp;idx=1&amp;sn=96fd170cc186e2b070ff1088ca8c50b4&amp;chksm=a7680d6e0c6069088cb78204f0d38a3edd69568a5608a80be11a7fecafd71ca4a0e8681901ae&amp;scene=0&amp;xtrack=1#rd</link><description><![CDATA[那会儿还没什么“智能指针”。你写的就是 C with classes。能跑就行。能上线就更行。资源这件事。基本靠自觉。new 之后。你得自己去把 delete 找回来。找不回来。就等着哪天线上给你脸色]]></description><author>everystep</author><pubDate>Wed, 21 Jan 2026 07:00:00 +0800</pubDate></item><item><title>为什么不要用 system_clock 计时：chrono 的一个老坑</title><link>http://mp.weixin.qq.com/s?__biz=MjM5NjAxMzk4NA==&amp;mid=2247497624&amp;idx=2&amp;sn=6c4973d2da9a81484d6f30bb5ae6e622&amp;chksm=a744915c0727b0331df4411c22f1523aae712400b18b7921c4a72e5647081a95103e43498d2e&amp;scene=0&amp;xtrack=1#rd</link><description><![CDATA[时间这东西。最喜欢伪装成“一个数字”。你看着它。觉得没啥。然后线上啪一下。很久以前。我们还没有那种“把单位写进类型里”的安全感。也没有一个统一的时间工具箱。时间就是 int。单位靠约定。约定靠注释。注]]></description><author>everystep</author><pubDate>Wed, 21 Jan 2026 07:00:00 +0800</pubDate></item><item><title>从“长度丢了”到“长度写进类型”：std::array 的来路</title><link>http://mp.weixin.qq.com/s?__biz=MjM5NjAxMzk4NA==&amp;mid=2247497622&amp;idx=1&amp;sn=5b7a542b4da5a511b6cc454af7161edf&amp;chksm=a7206e81903b61c040bcd10db485bf22be17be51106ceee5c90f45170509df9b6e70fc406bc8&amp;scene=0&amp;xtrack=1#rd</link><description><![CDATA[如果你写过一点 C。你大概率相信过一句话。数组的长度。就在那对 [] 里。写着呢。不会丢。结果第一次做小项目上了线。啪。你会发现。长度不是“丢了”。是你从来没真正拥有过它。那是很早的年代。大家写的不是]]></description><author>everystep</author><pubDate>Tue, 20 Jan 2026 07:00:00 +0800</pubDate></item><item><title>future / promise / async：少写一点并发的土协议</title><link>http://mp.weixin.qq.com/s?__biz=MjM5NjAxMzk4NA==&amp;mid=2247497622&amp;idx=2&amp;sn=5efb9d569302787ee9eec4354cebe851&amp;chksm=a7c667b056c6cb99cf58b21a9d677ad2193c0d6b4c5fde48417c39984a7834232581b1319729&amp;scene=0&amp;xtrack=1#rd</link><description><![CDATA[那会儿还没有 C++11。也没有 std::thread。更别提 std::async。你想并发。就去写 pthread。或者上 Boost。然后把“结果”塞回主线程。靠全局变量。靠输出参数。靠一堆锁]]></description><author>everystep</author><pubDate>Tue, 20 Jan 2026 07:00:00 +0800</pubDate></item><item><title>完美转发：不是技巧，是别自作主张</title><link>http://mp.weixin.qq.com/s?__biz=MjM5NjAxMzk4NA==&amp;mid=2247497620&amp;idx=1&amp;sn=a293b0d9c72b045fdd5903bff79b6958&amp;chksm=a709a2dca15d3fc22f3cb585cfc34f419c8cb546e84987d61b3e69113f74a54423a6bec46f16&amp;scene=0&amp;xtrack=1#rd</link><description><![CDATA[在 C++11 之前。写 C++ 很像写 C。只不过多了个 class。那会儿没有 std::move。也没有右值引用这种东西。你想把一个对象传给别人。通常就一个动作。拷贝。对只写过 C 的人来说。拷]]></description><author>everystep</author><pubDate>Mon, 19 Jan 2026 07:00:00 +0800</pubDate></item><item><title>从 Boost 到 C++11：type traits 这套“类型体检”怎么来的</title><link>http://mp.weixin.qq.com/s?__biz=MjM5NjAxMzk4NA==&amp;mid=2247497620&amp;idx=2&amp;sn=c6ca435940d4f1d66f9bfe3642cf54b6&amp;chksm=a70d469c0d48ab87c4759e18c804a0c15402439a3298c497d9fa5fb5d6963b0ff51e5b1a5df3&amp;scene=0&amp;xtrack=1#rd</link><description><![CDATA[我想先把时间拨回去。拨回到一个更野的年代。那会儿你也写模板。也会写一个 T。然后你盯着它发呆。这玩意到底是不是整数。能不能拷贝。是不是引用。是不是我想要的那个类型。你问得很认真。但编译器只回你一句。“]]></description><author>everystep</author><pubDate>Mon, 19 Jan 2026 07:00:00 +0800</pubDate></item><item><title>C# 强制你写 override，C++ 为什么不？答案比你想的现实</title><link>http://mp.weixin.qq.com/s?__biz=MjM5NjAxMzk4NA==&amp;mid=2247497570&amp;idx=1&amp;sn=189452b379530ece7faea9ab8b5fe637&amp;chksm=a7bfdffcc3e141a31ecf35e7ff4a65cd9ede74ecffb032c1b123009f78243ef5d136c0dd76d8&amp;scene=0&amp;xtrack=1#rd</link><description><![CDATA[那会儿还没有这些“把意图写进语法”的小工具。大家写的还是 C with classes。写着写着。项目就长大了。然后线上啪一下。你才发现。最贵的不是崩溃。是“它居然没按我想的跑”。那些年，覆写靠的是记]]></description><author>everystep</author><pubDate>Sun, 18 Jan 2026 07:00:00 +0800</pubDate></item><item><title>以前我们用宏、enum、模板在“凑合”；C++11 终于给了一个像话的办法</title><link>http://mp.weixin.qq.com/s?__biz=MjM5NjAxMzk4NA==&amp;mid=2247497570&amp;idx=2&amp;sn=c5099230b835f924fe478fe380182cde&amp;chksm=a76cabbdc3fe9ae28c5ebd35dceb7c28278a54edb9fbd69bb8372e4dc6bd07e7639cad1613d8&amp;scene=0&amp;xtrack=1#rd</link><description><![CDATA[那会儿你写一个“常量”。多半就是一行 #define。写上去。编译过。就当它永远不会变。直到有一天。它变了。而你是在凌晨两点才知道的。一个小项目，线上啪一下当年我们做过那种“小得不能再小”的服务。一个]]></description><author>everystep</author><pubDate>Sun, 18 Jan 2026 07:00:00 +0800</pubDate></item><item><title>从 GCC 方言到 C++11：对齐这事，终于不用靠传说了</title><link>http://mp.weixin.qq.com/s?__biz=MjM5NjAxMzk4NA==&amp;mid=2247497568&amp;idx=1&amp;sn=ab65ad722a421844447293efdb545158&amp;chksm=a76bf32bbbfbf2557614a31c297d46d7ee2d31c1ded5c34d8f1ce98be361389ac6c4ca03e806&amp;scene=0&amp;xtrack=1#rd</link><description><![CDATA[那会儿我们写 C。也写一点 C with classes。项目不大。胆子不小。我们总觉得。内存嘛。不就是一排字节。指针嘛。不就是一把钥匙。直到有一天。线上啪一下。不是逻辑错。是进程没了。还特别挑人。你]]></description><author>everystep</author><pubDate>Sat, 17 Jan 2026 07:00:00 +0800</pubDate></item><item><title>你要的是性能，还是正确性？锁、atomic、thread_local 你到底该选谁</title><link>http://mp.weixin.qq.com/s?__biz=MjM5NjAxMzk4NA==&amp;mid=2247497568&amp;idx=2&amp;sn=98872bfc9d1efc7cbbac288adc5a77cf&amp;chksm=a7c03400423ddb133cd73e1d0ae8b1f9386d46b9c68758e5e0bc7bf7f2496cb72b724453e9a6&amp;scene=0&amp;xtrack=1#rd</link><description><![CDATA[有段时间。我们写程序。写着写着就会开始用线程。一个请求一个线程。或者一个线程池。那时候的痛点很朴素。我想要一个“全局变量”。但我只想让它对当前线程有效。别的线程别来碰瓷。那些年：没有“每线程一份全局”]]></description><author>everystep</author><pubDate>Sat, 17 Jan 2026 07:00:00 +0800</pubDate></item><item><title>你学 C 学出来的“非 0 就真”，在 C++ 里会害你</title><link>http://mp.weixin.qq.com/s?__biz=MjM5NjAxMzk4NA==&amp;mid=2247497566&amp;idx=1&amp;sn=84131cdd1e0907613ac1ff0c276f8e65&amp;chksm=a7354014a21c5ad822735c938b67e73969a192e148f8ef1955dea747813c6b66ec0a9245e65b&amp;scene=0&amp;xtrack=1#rd</link><description><![CDATA[那是很多年前。办公室的灯。经常亮到半夜。我们写的 C++。其实就是 C。外加一点 class。那时候最响的一句话是。“能跑就行。”后来我才知道。有些东西。一旦“能跑”。就会跑去你没想到的地方。那会儿的]]></description><author>everystep</author><pubDate>Fri, 16 Jan 2026 07:00:00 +0800</pubDate></item><item><title>宏让你少打字，也能让你背锅：单位这坑，C++11怎么补</title><link>http://mp.weixin.qq.com/s?__biz=MjM5NjAxMzk4NA==&amp;mid=2247497566&amp;idx=2&amp;sn=7a9021eb7d7a2f4bcaaad9ac003f8f01&amp;chksm=a78f0c5e3db9f61df50e88e37286ea448cb51a022a8a57aa51771feedf9f7232289bd204bf47&amp;scene=0&amp;xtrack=1#rd</link><description><![CDATA[十几年前。大家写 C。后来写 C with classes。代码里最常见的“类型”。就俩。int。double。数字一多。单位就开始飘。今天你写的是“500”。明天别人读成了“500”。然后线上啪一下]]></description><author>everystep</author><pubDate>Fri, 16 Jan 2026 07:00:00 +0800</pubDate></item><item><title>为什么别的语言早就有“原始字符串”，C++ 却让我们多熬了 10 年？</title><link>http://mp.weixin.qq.com/s?__biz=MjM5NjAxMzk4NA==&amp;mid=2247497564&amp;idx=1&amp;sn=4b0e6e2361781266edaacbdfddb7f7d0&amp;chksm=a74edddf7cbbc89db7cbc4044fa9e2dcc06d9644492c276455cf3ed035af5cb66e6e40d89d23&amp;scene=0&amp;xtrack=1#rd</link><description><![CDATA[那会儿我们写 C++。还是 “C with classes” 那味。项目不大。但线上一样会出事。出事的时候。你不会先怀疑字符串。你会先怀疑自己的人生选择。有一次半夜。线上突然开始找不到配置文件。日志里]]></description><author>everystep</author><pubDate>Thu, 15 Jan 2026 07:00:00 +0800</pubDate></item><item><title>重复的构造函数，本质上是在复制 bug。</title><link>http://mp.weixin.qq.com/s?__biz=MjM5NjAxMzk4NA==&amp;mid=2247497564&amp;idx=2&amp;sn=cc0a1d51874d06b093fb62dd022eb881&amp;chksm=a7bac832de3e826107fd7f68df87e5e247e2812fc7d6dda671f3aa25f3789b36beefb86aef91&amp;scene=0&amp;xtrack=1#rd</link><description><![CDATA[那会儿我们写 C++。很多人嘴上说 C++。手里其实还是 C。最多再加点 class。构造函数也一样。它看起来像“自动帮你把对象弄好”。但你真写过几天。就会发现它更像“手动装配流水线”。而且没有复用。]]></description><author>everystep</author><pubDate>Thu, 15 Jan 2026 07:00:00 +0800</pubDate></item><item><title>虚函数不是玄学：它只是把“手写函数表”收编了</title><link>http://mp.weixin.qq.com/s?__biz=MjM5NjAxMzk4NA==&amp;mid=2247497562&amp;idx=1&amp;sn=ce654c9259c5844c149b37944c40606e&amp;chksm=a7c5ebe215569e18b62b946d76815859f8352eac57597b6bd955579b99928f0d61dc8747d5dc&amp;scene=0&amp;xtrack=1#rd</link><description><![CDATA[你写下 p->foo()。看起来像一句话。像一句很普通的话。可在当年。这句话是很多人用 crash 堆出来的。而且那种 crash。通常还不在你写错的地方。“C++ makes it harder t]]></description><author>everystep</author><pubDate>Wed, 14 Jan 2026 07:40:00 +0800</pubDate></item><item><title>写库的人都爱这一招：NVI（非虚接口）怎么把流程锁住</title><link>http://mp.weixin.qq.com/s?__biz=MjM5NjAxMzk4NA==&amp;mid=2247497562&amp;idx=2&amp;sn=b222cd667a743aaeb6abc0c41f60659d&amp;chksm=a77a264c7df339bd050d24fb7bd443af2f226389927941c5beff72c73f3c75f37c85ba3ac3ff&amp;scene=0&amp;xtrack=1#rd</link><description><![CDATA[那时候还没有“接口”这个词。大家写的更多是“约定”。写在邮件里。写在 README 里。写在某个老同事的脑子里。然后项目一大。约定就开始漏风。在没有纯虚函数的年代：大家怎么写“可扩展”的代码C 时代的]]></description><author>everystep</author><pubDate>Wed, 14 Jan 2026 07:40:00 +0800</pubDate></item><item><title>从 C 的返回码到 Rust 的 Result：C++ 为什么非要搞出 noexcept？</title><link>http://mp.weixin.qq.com/s?__biz=MjM5NjAxMzk4NA==&amp;mid=2247497561&amp;idx=1&amp;sn=387180a6649eb1999336fa4b34fd52c4&amp;chksm=a7868d303bd3addc84210d3c6b8631db924002852f45e61d308bc8e38007fe8da23661db2815&amp;scene=0&amp;xtrack=1#rd</link><description><![CDATA[异常这东西。在 C 的世界里。它一开始其实很朴素。函数失败了。就返回一个值。-1。或者塞个 errno。你再写一层。就再把这个值往上抛。一路抛到 main。人也跟着老了几岁。后来 C++ 来了。带着类]]></description><author>everystep</author><pubDate>Tue, 13 Jan 2026 07:00:00 +0800</pubDate></item><item><title>模板报错像天书？把 static_assert 放进去，编译器立刻讲明白</title><link>http://mp.weixin.qq.com/s?__biz=MjM5NjAxMzk4NA==&amp;mid=2247497561&amp;idx=2&amp;sn=f2fe5f2a012ff697f3b82fbc00465567&amp;chksm=a7422831c9a20741ad2cda7f1b1207f49e3017a870c26fad89a4b4d716d64753df7d4c0c7205&amp;scene=0&amp;xtrack=1#rd</link><description><![CDATA[那会儿我刚从 C 走到 C with classes。项目不大。人也不多。我们写代码的标准很简单。能跑。就算赢。直到有一天。同一份程序。在我机子上不炸。到了客户那台机器。啪一下。我去问原因。没人能一句]]></description><author>everystep</author><pubDate>Tue, 13 Jan 2026 07:00:00 +0800</pubDate></item><item><title>从函数指针到虚函数表：C++ 把‘回调套路’收编了</title><link>http://mp.weixin.qq.com/s?__biz=MjM5NjAxMzk4NA==&amp;mid=2247497524&amp;idx=1&amp;sn=e2b3d2b6343dc7e1584870222e8138be&amp;chksm=a7691670c3271eadd02832a79939a25e3ac4d9094c39b230d248b250bac22c955c3d257393c9&amp;scene=0&amp;xtrack=1#rd</link><description><![CDATA[有段时间。大家写“面向对象”。但代码看起来还是 C。一个 struct。再塞几根函数指针。能跑。也挺灵活。然后某天。 线上炸了。你去看 core dump。发现是一个空指针。指向一张你以为“永远不会空]]></description><author>everystep</author><pubDate>Mon, 12 Jan 2026 07:00:00 +0800</pubDate></item><item><title>构造/析构里调用 virtual：看起来省事，实际很悬</title><link>http://mp.weixin.qq.com/s?__biz=MjM5NjAxMzk4NA==&amp;mid=2247497524&amp;idx=2&amp;sn=46673d5499af1adce8c0906ffd9b068c&amp;chksm=a78f1625ec6af3694ba4d5a7c63cbc09db35cdc4c1950357a10ad1fe5c9a626868af0376e9d6&amp;scene=0&amp;xtrack=1#rd</link><description><![CDATA[那是一个很老的坑。老到它比“现代 C++”还早。老到你第一次见到它。会怀疑：是不是我把语言学错了。它不报错。它也不崩。它只是很安静地。做了你没预期的事。当年没有“虚函数”这个词先把时间拨回去。那会儿很]]></description><author>everystep</author><pubDate>Mon, 12 Jan 2026 07:00:00 +0800</pubDate></item><item><title>把 cast 当成声明意图：一眼看出这行代码在冒什么险</title><link>http://mp.weixin.qq.com/s?__biz=MjM5NjAxMzk4NA==&amp;mid=2247497522&amp;idx=1&amp;sn=a605b479cf48073678976193e6253647&amp;chksm=a7c1109001d487d672b932a240977e78a91c7d3b5bccfdb68c51f08cd9178cf041f569e074e9&amp;scene=0&amp;xtrack=1#rd</link><description><![CDATA[那些年。你写的是 C。写着写着。就写成了“带点 class 的 C”。编译器不怎么唠叨。IDE 也不怎么提醒你：这行代码危险。你要把一个东西当成另一个东西用。最顺手的，还是那一对括号。你写的时候很放心]]></description><author>everystep</author><pubDate>Sun, 11 Jan 2026 10:09:48 +0800</pubDate></item><item><title>虚函数重写的自救指南：override、final、默认参数与隐藏</title><link>http://mp.weixin.qq.com/s?__biz=MjM5NjAxMzk4NA==&amp;mid=2247497522&amp;idx=2&amp;sn=730a2af3e9427451daa13f0208d4ac38&amp;chksm=a70b26534cf659d62703253ff789fb4a6dc462178c4389fa11c6c47d9d05df70040e8c5ca3b7&amp;scene=0&amp;xtrack=1#rd</link><description><![CDATA[那会儿写 C++。大家都挺自信。尤其是刚把代码“改对”。编译通过。单元测试也绿了。你心里想。这事就算完了。然后线上给你回了一巴掌。不是崩溃。更讨厌。它“能跑”。只是行为不对。而且还很像“偶发”。你开始]]></description><author>everystep</author><pubDate>Sun, 11 Jan 2026 10:09:48 +0800</pubDate></item><item><title>我当年也没搞懂：`virtual` 到底在替我们做什么</title><link>http://mp.weixin.qq.com/s?__biz=MjM5NjAxMzk4NA==&amp;mid=2247497517&amp;idx=1&amp;sn=b564704164885467b854c462fcf97c5a&amp;chksm=a7477e68fa754cd8c2784bd953963accb4ab248e1fb57a530819cf6ebe5423ef5fb23b6b96f5&amp;scene=0&amp;xtrack=1#rd</link><description><![CDATA[那时候写代码。大家更信指针。也更怕指针。你想写“通用代码”。比如你写了个小绘图工具。里面有圆。有矩形。还有些你自己临时加的形状。你只想写一段循环。让它们自己把自己画出来。在坑里长大的“多态”上世纪 8]]></description><author>everystep</author><pubDate>Sat, 10 Jan 2026 07:00:00 +0800</pubDate></item><item><title>对象切片：不是 bug 很难发现，是它太“正常”了</title><link>http://mp.weixin.qq.com/s?__biz=MjM5NjAxMzk4NA==&amp;mid=2247497517&amp;idx=2&amp;sn=bd9177069a89b10db797b946016becfb&amp;chksm=a710ce750d15fd5aa87384efad0900f09bd1a1cd43e49206cbe11d924986c3f789062cd9135b&amp;scene=0&amp;xtrack=1#rd</link><description><![CDATA[那时候大家刚学完 C。手里最顺的一招。就是“按值传”。不想碰指针。不想挨空指针的骂。更不想半夜被段错误叫醒。所以你很自然会想。把对象拷一份进函数里。我用我的。你用你的。互不干扰。听起来挺靠谱。后来 C]]></description><author>everystep</author><pubDate>Sat, 10 Jan 2026 07:00:00 +0800</pubDate></item><item><title>收到工资1182415.18元，爱你DeepSeek！</title><link>http://mp.weixin.qq.com/s?__biz=MjM5NjAxMzk4NA==&amp;mid=2247497494&amp;idx=1&amp;sn=efba8df67cda9b4c978e084e55fdbddd&amp;chksm=a71c6ac03bfc8cd5c9ca63c984c245b1686c9a4a2d72532bc9fa76469187b091c46180ad8a62&amp;scene=0&amp;xtrack=1#rd</link><description><![CDATA[今年DeepSeek爆火，生成式AI和大模型技术呈现爆发式增长，也让算法工程师重新成了炙手可热的岗位，岗位薪资远超很多运维、嵌入式、前后端岗位，在程序员中稳居前列。AI的快速发展也给很多程序员带来更多]]></description><author>everystep</author><pubDate>Fri, 09 Jan 2026 07:00:00 +0800</pubDate></item><item><title>同一个祖先，为什么会出现两份？聊聊菱形继承与虚继承</title><link>http://mp.weixin.qq.com/s?__biz=MjM5NjAxMzk4NA==&amp;mid=2247497480&amp;idx=1&amp;sn=2a69cc05a6dbc53caf844f169223ca54&amp;chksm=a7df61a50040408eb2c806f3ea45fbaccd6006fcfe7cfd91dd8eea7825a1ff149986fabfa8bb&amp;scene=0&amp;xtrack=1#rd</link><description><![CDATA[多重继承这东西。一开始不是为了炫技。是为了活下去。那是 80 年代。C++ 还叫 C with Classes。项目开始变大。文件多。人也多。复用的冲动特别真实。你写了一套“通用能力”：能打印，能扫描]]></description><author>everystep</author><pubDate>Thu, 08 Jan 2026 07:00:00 +0800</pubDate></item><item><title>你以为 private 继承“不能用”？其实就差这一句 using</title><link>http://mp.weixin.qq.com/s?__biz=MjM5NjAxMzk4NA==&amp;mid=2247497480&amp;idx=2&amp;sn=c8161a393fc842fd35927deb98d3ac05&amp;chksm=a7bf6e74317ee8524a8bc7e53a810768f22cacfb2c6336e07d275285734471bd55b72e464134&amp;scene=0&amp;xtrack=1#rd</link><description><![CDATA[有些语法。长得像小修小补。当年却真救过人。你写着写着。会突然发现。你想复用一个基类。但你不想把它的所有东西都“送出去”。更麻烦的是。你还不想为了这点事。去改基类。回到 C with Classes 的]]></description><author>everystep</author><pubDate>Thu, 08 Jan 2026 07:00:00 +0800</pubDate></item><item><title>同一个对象，两个门口：多重继承里的指针为什么会挪位？</title><link>http://mp.weixin.qq.com/s?__biz=MjM5NjAxMzk4NA==&amp;mid=2247497479&amp;idx=1&amp;sn=5fd8eb41611054eafd03762e72d8ecf8&amp;chksm=a71493901a50cd3dba26d9cea1cc1e94e8ab93ffb29be2fd8e5fc37124b7bad8e5c67a25e2cf&amp;scene=0&amp;xtrack=1#rd</link><description><![CDATA[80 年代的工程师很少一上来就讨论“对象模型”。他们更常讨论的是。这段代码能不能少复制一点。这个模块能不能少改几处。这个改动能不能别把整个项目带崩。那时候 C with Classes 还很年轻。你能]]></description><author>everystep</author><pubDate>Wed, 07 Jan 2026 07:00:00 +0800</pubDate></item><item><title>用现代 C++ 手搓一个 RISC-V 64 位模拟器</title><link>http://mp.weixin.qq.com/s?__biz=MjM5NjAxMzk4NA==&amp;mid=2247497479&amp;idx=2&amp;sn=44a35ffc1b57e463c7af577091f8635e&amp;chksm=a798f39bf76cc591eb9466df39a63bd0e77df2bcebb7826789d9e45a5ab93d0b182ada356881&amp;scene=0&amp;xtrack=1#rd</link><description><![CDATA[——给求职焦虑的你，一个能写进简历、也能讲进面试的虚拟 CPU 项目很多年之后。你再回头看那段找工作的时间。大概率只记得两件事。一件事。刷题。刷到怀疑人生。另一件事。面试官翻着你的简历。抬头问一句：“]]></description><author>everystep</author><pubDate>Wed, 07 Jan 2026 07:00:00 +0800</pubDate></item><item><title>别再把 public/protected/private 当“权限”了</title><link>http://mp.weixin.qq.com/s?__biz=MjM5NjAxMzk4NA==&amp;mid=2247497458&amp;idx=1&amp;sn=269e171365b5c7e2cbb6b09c43589efa&amp;chksm=a701193e039c880cdc8a0cd4dfe93503ccb819da96fc9ee3255f105de37c8adc051494567b70&amp;scene=0&amp;xtrack=1#rd</link><description><![CDATA[很久以前。大家写 C。想复用。只能复制粘贴。或者写一堆宏。也有人开始玩“结构体套结构体”。看起来像继承。但谁都知道。这东西全靠自觉。自觉这种东西。最不可靠。C with Classes 出现以后，新的]]></description><author>everystep</author><pubDate>Tue, 06 Jan 2026 07:00:00 +0800</pubDate></item><item><title>从 struct 套 struct 到 C++ 继承：中间踩过哪些坑？</title><link>http://mp.weixin.qq.com/s?__biz=MjM5NjAxMzk4NA==&amp;mid=2247497458&amp;idx=2&amp;sn=936893cb2c1a1f1687a389f98930b0f9&amp;chksm=a74d42d344b563e57b4c3e726daa32bed890a6ca57a55f9de6f4984ec342526f30f0935f7f93&amp;scene=0&amp;xtrack=1#rd</link><description><![CDATA[那会儿大家写 C。写在一堆 .c 和 .h 里。项目开始变大。但工具和语言，还是那个工具和语言。你想复用一段逻辑。第一反应不是“继承”。第一反应是：复制粘贴。然后祈祷别漏改。再然后。你就会开始讨厌自己]]></description><author>everystep</author><pubDate>Tue, 06 Jan 2026 07:00:00 +0800</pubDate></item><item><title>用“拷贝”做“交接”，到底会出什么事？auto_ptr 给过答案</title><link>http://mp.weixin.qq.com/s?__biz=MjM5NjAxMzk4NA==&amp;mid=2247497447&amp;idx=1&amp;sn=caaf3b873ee46aa82cc535471d296af2&amp;chksm=a70a0d784ba2ffd234bcc674649a3db42ab458a50c1aa8d521b1273415dbc563b1707076c588&amp;scene=0&amp;xtrack=1#rd</link><description><![CDATA[你第一次见到 std::move。大概率会被名字骗一下。move。那不就是“移动”吗。于是你心里会冒出一个很自然的画面。我把东西 move 走。原来的地方就空了。然后你会以为性能会更好。故事要从更早的]]></description><author>everystep</author><pubDate>Mon, 05 Jan 2026 07:00:00 +0800</pubDate></item><item><title>你不一定需要 static_assert，但你迟早会想要它</title><link>http://mp.weixin.qq.com/s?__biz=MjM5NjAxMzk4NA==&amp;mid=2247497447&amp;idx=2&amp;sn=fec617b84c125cf887fc09e140d604be&amp;chksm=a71fb68dff1f6fad49fb02686928a58f51c6812f6089fbc6c94b66d03ba5aaf722637db8f500&amp;scene=0&amp;xtrack=1#rd</link><description><![CDATA[那会儿我刚从 C 走到 C with classes。项目不大。人也不多。我们写代码的标准很简单。能跑。就算赢。直到有一天。同一份程序。在我机子上不炸。到了客户那台机器。啪一下。我去问原因。没人能一句]]></description><author>everystep</author><pubDate>Mon, 05 Jan 2026 07:00:00 +0800</pubDate></item><item><title>你把 malloc 的指针当对象用？这不是“能跑”，这是在等一次大爆炸</title><link>http://mp.weixin.qq.com/s?__biz=MjM5NjAxMzk4NA==&amp;mid=2247497442&amp;idx=1&amp;sn=47d6763b70a3efc2c902670ab2126057&amp;chksm=a7899f6d6bf4c9427fcb6763f0d1c4d708cf777b78cee4cd9e38b0cb71f43af3e4282dd15c70&amp;scene=0&amp;xtrack=1#rd</link><description><![CDATA[八十年代初。贝尔实验室里有一拨人。他们在用 C 写系统。代码能跑。但维护很痛。痛点不新鲜。就是“忘了收尾”。忘了 destroy。忘了 free。忘了某个 init。然后线上开始讲鬼故事。有人想把这事]]></description><author>everystep</author><pubDate>Sun, 04 Jan 2026 07:00:00 +0800</pubDate></item><item><title>我一直以为返回类型只能靠猜，直到我看到 decltype 那一行</title><link>http://mp.weixin.qq.com/s?__biz=MjM5NjAxMzk4NA==&amp;mid=2247497442&amp;idx=2&amp;sn=d49cadf452171c86fbe6992fa2784057&amp;chksm=a792c7782c64a3299fedca8a567ecf297354c36b982a3eea03608c6a32b67cdc37824816a5cd&amp;scene=0&amp;xtrack=1#rd</link><description><![CDATA[decltype 这玩意，到今天都像个老朋友……它不是为了让你写得更“高级”，而是为了让类型别再靠猜。你写模板写到凌晨，就会理解这句话的分量。那会儿还叫 C++0x，标准还没定，可项目已经要交付了。你]]></description><author>everystep</author><pubDate>Sun, 04 Jan 2026 07:00:00 +0800</pubDate></item><item><title>用现代 C++ 从零手写智能指针</title><link>http://mp.weixin.qq.com/s?__biz=MjM5NjAxMzk4NA==&amp;mid=2247497436&amp;idx=1&amp;sn=81ced5dcd919891c14d56f73d54e0fd0&amp;chksm=a772349c6782dfd2f1b44b41d930301c6841dbdecc8a2114af5baf667f63b30e9a7c63670968&amp;scene=0&amp;xtrack=1#rd</link><description><![CDATA[——给想把“内存管理/RAII”真正讲清楚的你，一套可验证的硬核训练很多年之后。你再回头看那段找工作的时间。大概率会记得两件事。一件事。刷题。刷到怀疑人生。另一件事。面试官翻着你的简历。抬头问一句：“]]></description><author>everystep</author><pubDate>Sat, 03 Jan 2026 07:00:00 +0800</pubDate></item><item><title>一个类，一份变量：你写了 static，就等于默认引入了“全局状态”</title><link>http://mp.weixin.qq.com/s?__biz=MjM5NjAxMzk4NA==&amp;mid=2247497436&amp;idx=2&amp;sn=89a9f6a7529be95542b631b7375d75e5&amp;chksm=a77aa3ebbdaa99c18fe6168eaafc40a2920b714682e0371578966aacef39b74cf5d58e55102b&amp;scene=0&amp;xtrack=1#rd</link><description><![CDATA[我第一次被“静态成员”坑到。不是崩溃。是链接错误。那种很有年代感的红字。undefined reference to Foo::kCount当年我还以为自己把 C++ 写坏了。后来才明白。我只是把“变]]></description><author>everystep</author><pubDate>Sat, 03 Jan 2026 07:00:00 +0800</pubDate></item><item><title>宏写得越爽，线上炸得越响</title><link>http://mp.weixin.qq.com/s?__biz=MjM5NjAxMzk4NA==&amp;mid=2247497424&amp;idx=1&amp;sn=75129630d0717fdf31d7b6d281edae70&amp;chksm=a7f4b0ce08417ce97dd15730e533854682b71e71f4b89cc848c54c6489ab7d6ab80d267419c0&amp;scene=0&amp;xtrack=1#rd</link><description><![CDATA[我第一次真正在意“常量”。不是因为它难。是因为它太容易被写错。然后还很难查。那会儿我在修一个老项目。头文件里全是 #define。像家谱。谁也不敢动。但线上就是这么爱挑这种时候出事。某次夜里。报警响了]]></description><author>everystep</author><pubDate>Fri, 02 Jan 2026 07:27:00 +0800</pubDate></item><item><title>只改了一个成员声明顺序，我把一个“玄学崩溃”变成了可解释的 bug</title><link>http://mp.weixin.qq.com/s?__biz=MjM5NjAxMzk4NA==&amp;mid=2247497424&amp;idx=2&amp;sn=ac45805dad1b5725d91e8f91c6389861&amp;chksm=a728de4fd0bb487bfa166a0947de500f3ac9b84d638ade42401684c4d30697f247fa0dd5671f&amp;scene=0&amp;xtrack=1#rd</link><description><![CDATA[那天我都准备下班了。工位灯都关了一半。群里突然有人 @我。“线上有个小服务。启动就崩。刚发的版本。”我第一反应是。谁又把构造函数玩坏了。因为这种事故有个味道。像新买的咖啡机。啪一声。跳闸。我们那会儿刚]]></description><author>everystep</author><pubDate>Fri, 02 Jan 2026 07:27:00 +0800</pubDate></item><item><title>空类为啥也要收你 1 个字节？不懂这个，迟早在“对象地址”上翻车</title><link>http://mp.weixin.qq.com/s?__biz=MjM5NjAxMzk4NA==&amp;mid=2247497406&amp;idx=1&amp;sn=40829a4370e1c2a8a6973c5845e095e7&amp;chksm=a750be460627480efdd2161a0be442218e9c218b86efed78380b9cc3d8a356487a62ae7575b7&amp;scene=0&amp;xtrack=1#rd</link><description><![CDATA[我第一次看到这句输出。是很多年前。一个老同事把打印丢给我。他说。“你看，C++ 连空都不让你空。”#include <iostream>struct Empty {};int main() {]]></description><author>everystep</author><pubDate>Wed, 31 Dec 2025 07:00:00 +0800</pubDate></item><item><title>auto 一用就爽？先把引用和 const 这关过了</title><link>http://mp.weixin.qq.com/s?__biz=MjM5NjAxMzk4NA==&amp;mid=2247497406&amp;idx=2&amp;sn=1606deb194b4d8b088ac2514e61fd353&amp;chksm=a791a09931cdc091c91c5391bf6fff1531cd5324060f3ec8a5893750df09ca6a3ce60c021c3e&amp;scene=0&amp;xtrack=1#rd</link><description><![CDATA[auto 这东西。我第一次认真看它。不是在 C++11。是在更早的老代码里。那种你一打开就能闻到“2003 年味道”的工程。你会看到一堆熟悉的老朋友。static。extern。register。还有]]></description><author>everystep</author><pubDate>Wed, 31 Dec 2025 07:00:00 +0800</pubDate></item><item><title>把 C++ 的“面向对象”刮掉：剩下的就是 C、指针、和编译器的手法</title><link>http://mp.weixin.qq.com/s?__biz=MjM5NjAxMzk4NA==&amp;mid=2247497404&amp;idx=1&amp;sn=d1ef9ded0ec039b21465a439c7e6484d&amp;chksm=a7176e5498943f4a21fb724a8f92e8c076bbfc77e901e8d2192d727ad562c6e441e876739bc1&amp;scene=0&amp;xtrack=1#rd</link><description><![CDATA[我刚学 C 的时候。函数很“老实”。你要它改谁。你就把谁的地址传进去。void inc(int* p) {    ++*p;}int x = 0;inc(&x);你看。谁被改。一眼就知道。后来我第一次]]></description><author>everystep</author><pubDate>Tue, 30 Dec 2025 07:00:00 +0800</pubDate></item><item><title>内存不是黑盒：把它想成一排“字节格子”，一切突然就通了</title><link>http://mp.weixin.qq.com/s?__biz=MjM5NjAxMzk4NA==&amp;mid=2247497404&amp;idx=2&amp;sn=effe949d58f8a3dd55822de5d1f4b9d3&amp;chksm=a78f9d8c0539ba3085d3b0f6d7c4d6c9124aa03b024576eac84ac4b9eab9fa27c27d5e209f68&amp;scene=0&amp;xtrack=1#rd</link><description><![CDATA[内存不是黑盒。你把它想成一排“字节格子”。从地址 0 排到地址 N-1。每一格。正好 1 个字节。很多问题就不再神秘。比特。字节。地址。sizeof。会在同一张图上对齐。很多教材也会用一句话开头。然后]]></description><author>everystep</author><pubDate>Tue, 30 Dec 2025 07:00:00 +0800</pubDate></item><item><title>把对象当内存看懂一次，你的 C++ 会突然顺很多</title><link>http://mp.weixin.qq.com/s?__biz=MjM5NjAxMzk4NA==&amp;mid=2247497389&amp;idx=1&amp;sn=61a4b31f9818a395a73c8b2463861e81&amp;chksm=a7c63275316cd454432e4893768e508f5984922fd723d887f0e274cee0e8d03b9ead35a49bea&amp;scene=0&amp;xtrack=1#rd</link><description><![CDATA[我最早学 C 的时候。老师不爱讲“对象”。他只讲内存。讲地址。讲 malloc。然后拍着黑板说。“结构体就是一段连续的字节。”这句话听起来粗。但它很诚实。后来我开始写 C++。同样的结构体。突然就能有]]></description><author>everystep</author><pubDate>Mon, 29 Dec 2025 07:00:00 +0800</pubDate></item><item><title>成员顺序随手一换，sizeof 直接翻倍：你写的不是结构体，是利息</title><link>http://mp.weixin.qq.com/s?__biz=MjM5NjAxMzk4NA==&amp;mid=2247497389&amp;idx=2&amp;sn=08345b0bb3bac31a1b98effce00d584c&amp;chksm=a723792619cecbb53cc7f60bf56290761e9b63badc6e0660f389c7b9b2ad64d8ea92a9fb63e2&amp;scene=0&amp;xtrack=1#rd</link><description><![CDATA[我第一次被 sizeof 教做人。不是在课堂。是在一次很真实的协议联调里。那会儿我还年轻。看见结构体就手痒。总觉得它天生适合当包头。于是我写了一个很朴素的东西。#include <cstdint>st]]></description><author>everystep</author><pubDate>Mon, 29 Dec 2025 07:00:00 +0800</pubDate></item><item><title>用现代 C++ 手搓一个 RISC-V 模拟器</title><link>http://mp.weixin.qq.com/s?__biz=MjM5NjAxMzk4NA==&amp;mid=2247497376&amp;idx=1&amp;sn=a2cd93808464434c7a87a4ad169dbb18&amp;chksm=a72536bd722e9e42b79fc9ce5d909d88e2c9053396ff2231c59484be2e3fc52c5c396d3f214a&amp;scene=0&amp;xtrack=1#rd</link><description><![CDATA[——给求职焦虑的你，一个能写进简历、也能讲进面试的虚拟 CPU 项目很多年之后。你再回头看那段找工作的时间。大概率只记得两件事。一件事。刷题。刷到怀疑人生。另一件事。面试官翻着你的简历。抬头问一句：“]]></description><author>everystep</author><pubDate>Sun, 28 Dec 2025 07:00:00 +0800</pubDate></item><item><title>网络字节序为什么偏偏选大端？历史不是整齐的，但坑很整齐</title><link>http://mp.weixin.qq.com/s?__biz=MjM5NjAxMzk4NA==&amp;mid=2247497376&amp;idx=2&amp;sn=3247333b2c9038022972249943bbbfc2&amp;chksm=a740d2a216dd1fdaeae4781fffd52934812c859176a00e5a17b50d2fbe7a2d69a56f25b25aac&amp;scene=0&amp;xtrack=1#rd</link><description><![CDATA[如果你把时间往回拨。拨到那种“机房时代”。一台机器。一套生态。CPU、总线、外设。乃至编译器和文件格式。都在同一个家族谱里。那时候你很少听人争论“字节顺序”。不是因为大家更聪明。是因为边界更少。数据大]]></description><author>everystep</author><pubDate>Sun, 28 Dec 2025 07:00:00 +0800</pubDate></item><item><title>同事看到你还在写 it != end()：他已经在心里扣分了</title><link>http://mp.weixin.qq.com/s?__biz=MjM5NjAxMzk4NA==&amp;mid=2247497352&amp;idx=1&amp;sn=1108e7de0082f5f7bbca2587ce49ddaa&amp;chksm=a7e2be0e768d00678e4c25feac3877e1449b21be919a366f2ec33bb2b0c34ffcbe00b9c8cd26&amp;scene=0&amp;xtrack=1#rd</link><description><![CDATA[我第一次在代码评审里看到那种 for 循环。长得像一段咒语。你看得懂。但你不想再看第二遍。std::vector<int> v{1, 2, 3};for (std::vector<int>::iter]]></description><author>everystep</author><pubDate>Sat, 27 Dec 2025 07:00:00 +0800</pubDate></item><item><title>C++11 的花括号是把双刃剑：能救命，也能搞出事故</title><link>http://mp.weixin.qq.com/s?__biz=MjM5NjAxMzk4NA==&amp;mid=2247497352&amp;idx=2&amp;sn=eea1e52de1aba9907880cf53042f7385&amp;chksm=a7ac62b6a2f05806444f19096cf045f823cd8955c016f8b43767c0dd557358f8972f243a6d12&amp;scene=0&amp;xtrack=1#rd</link><description><![CDATA[我很早就认识花括号。那会儿还在写 C。它的工作很单纯。给数组塞初值。给 struct 填字段。int a[3] = {1, 2, 3};struct Point { int x; int y; };P]]></description><author>everystep</author><pubDate>Sat, 27 Dec 2025 07:00:00 +0800</pubDate></item><item><title>空指针这事，C++ 吵了很多年：最后为什么是 nullptr 胜出</title><link>http://mp.weixin.qq.com/s?__biz=MjM5NjAxMzk4NA==&amp;mid=2247497344&amp;idx=1&amp;sn=114cb5903c86da9815d87a229c4045aa&amp;chksm=a71b502135a4b7206a6645ee14e75819a2314dd3c13dd6cdc448a65d1bf0743f41c9a8ac01d8&amp;scene=0&amp;xtrack=1#rd</link><description><![CDATA[空指针这事。在 C++ 圈子里。真吵了很多年。有人说。写 0 就行。反正大家都懂。有人说。别装。老代码都写 NULL。还有人更直接。说这不是风格问题。是类型系统的问题。要解决就得给“空”一个类型。后来]]></description><author>everystep</author><pubDate>Fri, 26 Dec 2025 07:00:00 +0800</pubDate></item><item><title>printf 又坑我一次：C++20 std::format 来收拾残局</title><link>http://mp.weixin.qq.com/s?__biz=MjM5NjAxMzk4NA==&amp;mid=2247497344&amp;idx=2&amp;sn=bc2d505718df16c84755b2f21e95fd3c&amp;chksm=a763bbd3fb0d194bbf087cff102b21091bd65dc944a7b9fce2db5965ab49e4b2f01f13cf5a2c&amp;scene=0&amp;xtrack=1#rd</link><description><![CDATA[printf 这套东西。来自 C 的年代。那时候机器慢。内存小。接口越薄越好。可变参数一上。大家都觉得很优雅。然后代价就被悄悄塞进了“约定”。格式串要和参数对齐。你不对齐。它也不一定立刻骂你。它可能当]]></description><author>everystep</author><pubDate>Fri, 26 Dec 2025 07:00:00 +0800</pubDate></item><item><title>看懂 lambda，你就懂 C++11 在补哪一块历史窟窿</title><link>http://mp.weixin.qq.com/s?__biz=MjM5NjAxMzk4NA==&amp;mid=2247497331&amp;idx=1&amp;sn=a2b9c221a3e77ceebe6987fbf1a3ec8f&amp;chksm=a7eda8956d8cb2a210c83de4988ee063b8a1680397cd846ff507f97f24c6487a8a266558efa7&amp;scene=0&amp;xtrack=1#rd</link><description><![CDATA[lambda 不是突然冒出来的。它是 C++ 很长一段历史里。“回调”和“算法”把人逼出来的产物。九十年代 STL 把算法搬进标准库。sort、find_if、for_each 这些东西一出来。大家就]]></description><author>everystep</author><pubDate>Thu, 25 Dec 2025 07:00:00 +0800</pubDate></item><item><title>C++ 的默认规则有多阴？你写得越认真，它越不给你面子</title><link>http://mp.weixin.qq.com/s?__biz=MjM5NjAxMzk4NA==&amp;mid=2247497330&amp;idx=1&amp;sn=dd55b3d6191b2b97b67ec8837276850d&amp;chksm=a71827cb1738b284fa3147df6ad4d47b9dddbb45f53e4b19b281592bbf415ba55a0d507b099e&amp;scene=0&amp;xtrack=1#rd</link><description><![CDATA[我写 C 的那几年。struct 就是一块内存。你负责填。编译器不插嘴。你也不用去猜它的心思。后来开始写 C++。一开始还挺爽。我什么也没写。对象居然能“默认就能用”。还能拷贝。还能赋值。那会儿我以为]]></description><author>everystep</author><pubDate>Wed, 24 Dec 2025 07:00:00 +0800</pubDate></item><item><title>为什么我在新代码里几乎只写 enum class</title><link>http://mp.weixin.qq.com/s?__biz=MjM5NjAxMzk4NA==&amp;mid=2247497326&amp;idx=1&amp;sn=b6c703e2adbde0677b323846fa717949&amp;chksm=a7971a09dc67e6db95bd9308303fe83d8f3a3b1973f71270090c57991f90d734db341a9eeedf&amp;scene=0&amp;xtrack=1#rd</link><description><![CDATA[我第一次用 enum。是在一个还带着 C 味道的 C++ 项目里。那项目很老。老到你能在角落里闻到宏定义的烟味。当时我们刚从 #define RED 1 这种写法里缓过劲。看到 enum。心里一乐。“]]></description><author>everystep</author><pubDate>Tue, 23 Dec 2025 07:00:00 +0800</pubDate></item><item><title>UI 不该认识业务：命令模式把耦合切开，顺手送你撤销重做</title><link>http://mp.weixin.qq.com/s?__biz=MjM5NjAxMzk4NA==&amp;mid=2247497319&amp;idx=1&amp;sn=2ab9d95307a92a56c834571ff8d27427&amp;chksm=a7f131d3c529a3161f5534671411983e607458eb32faf455feb405dcb3a07694cd7f2ea9f29f&amp;scene=0&amp;xtrack=1#rd</link><description><![CDATA[命令这东西。比“设计模式”这个词老得多。我第一次听到“命令”这个词。不是在 UML。也不是在 GoF。是在机房。最早的“命令”不是对象。也不是函数。甚至不是代码。它是一张纸。一摞打孔卡。或者操作员手里]]></description><author>everystep</author><pubDate>Mon, 22 Dec 2025 22:03:31 +0800</pubDate></item><item><title>只需加一层“壳”，就能让你的对象百毒不侵</title><link>http://mp.weixin.qq.com/s?__biz=MjM5NjAxMzk4NA==&amp;mid=2247497314&amp;idx=1&amp;sn=0d489395cb24771f0fd25bc54f593163&amp;chksm=a732383f3e55c6abab5e78fa3e190e9ebc06377fccdfe00fecb662044067dbb03169b0e70f04&amp;scene=0&amp;xtrack=1#rd</link><description><![CDATA[职场里总有这么一种人。看着好像不干核心大活。但他不可或缺。老板找技术大牛签字，他挡着：“大牛在闭关，先放我这。”外部门来扯皮，他拦着：“这事儿不归我们管，出门左转。”甚至只有等到真正的大项目落地时。他]]></description><author>everystep</author><pubDate>Sat, 20 Dec 2025 07:00:00 +0800</pubDate></item><item><title>当年 Unix 管道教我的事：装饰器是加料，适配器是翻译</title><link>http://mp.weixin.qq.com/s?__biz=MjM5NjAxMzk4NA==&amp;mid=2247497310&amp;idx=1&amp;sn=0086677aace46e57984c644c9bb36dd2&amp;chksm=a7bf83f33d30fb60a91012b7ab030ddde726b4aa11fba7bd8b2e9633fa7d594851a7d6b32869&amp;scene=0&amp;xtrack=1#rd</link><description><![CDATA[我第一次真正“见到”装饰器。不是在 GoF。也不是在课堂。是在很早的 Unix 管道里。你写一条命令。前面负责产出。后面负责过滤。再后面负责格式化。最后丢进文件。每一段都像个小程序。每一段都只干一件事]]></description><author>everystep</author><pubDate>Fri, 19 Dec 2025 07:00:00 +0800</pubDate></item><item><title>一个 Adapter，干掉满工程的复制粘贴转换</title><link>http://mp.weixin.qq.com/s?__biz=MjM5NjAxMzk4NA==&amp;mid=2247497306&amp;idx=1&amp;sn=bc8f4288ebfbb11abcda42d9d1b714eb&amp;chksm=a75f581c2590f161514d80c6c75da187e2b171cb29ada6efbf82e81b826cee9e8071c67add3a&amp;scene=0&amp;xtrack=1#rd</link><description><![CDATA[九十年代写 C++。环境比今天朴素很多。库没有现在这么全。工具链也没现在这么顺。大家嘴上骂“祖传代码”。手上还得靠它跑生产。那会儿工程现场最常吵的词。一个叫“复用”。一个叫“兼容”。你接了一个新库。它]]></description><author>everystep</author><pubDate>Thu, 18 Dec 2025 07:00:00 +0800</pubDate></item><item><title>当你的 C++ 代码长成一片原始森林：结构型模式教你砍出一条路</title><link>http://mp.weixin.qq.com/s?__biz=MjM5NjAxMzk4NA==&amp;mid=2247497302&amp;idx=1&amp;sn=a0d6518ce0d5c7a0b79b36fe1ab7b785&amp;chksm=a79277d6c4d19b9e977324206898d4a0a87abaa166ef604eff16cfaf0d39b5c0af3b9c311c3b&amp;scene=0&amp;xtrack=1#rd</link><description><![CDATA[如果说创建型模式关心的是“对象怎么出生、谁来拍板 new 谁”， 那结构型模式盯着的，就是那些已经出生、满地乱跑的对象，是怎么被你拼在一起的。很多人第一次意识到“结构这件事有点不对劲”，往往是在一个写]]></description><author>everystep</author><pubDate>Wed, 17 Dec 2025 07:00:00 +0800</pubDate></item><item><title>求求你们，别再手动写析构函数了</title><link>http://mp.weixin.qq.com/s?__biz=MjM5NjAxMzk4NA==&amp;mid=2247497298&amp;idx=1&amp;sn=c611eb398657369228b6c41d3c0e1b09&amp;chksm=a7f59884fb096fcf88a077d28599f1faefa6e4def51f2fe3e0d8724493c02c7135b2ac806649&amp;scene=0&amp;xtrack=1#rd</link><description><![CDATA[我第一次听到 Rule of 3。是在一次线上事故复盘会上。会议室里烟味很重。日志也很重。那位老前辈把一段代码甩到投影上。struct Buf {    int* p = new int[4];]]></description><author>everystep</author><pubDate>Tue, 16 Dec 2025 07:00:00 +0800</pubDate></item><item><title>我见过太多 copy 事故：深拷贝浅拷贝这点事得讲明白</title><link>http://mp.weixin.qq.com/s?__biz=MjM5NjAxMzk4NA==&amp;mid=2247497294&amp;idx=1&amp;sn=df74835f494cd1de477b2771efabfa8e&amp;chksm=a7ccd960bd5362b970e3f131a769cefcf60df01158dc366669b8e3f3f8e3ac8ded492cd8aec9&amp;scene=0&amp;xtrack=1#rd</link><description><![CDATA[我见过很多“深拷贝 / 浅拷贝”的事故现场。它们的开头都挺朴素。你写下一行。看着很正派。甚至还有点洁癖。std::vector<T*> copy = v;编译过了。单测也过了。然后你就把它合了。等到某]]></description><author>everystep</author><pubDate>Mon, 15 Dec 2025 07:00:00 +0800</pubDate></item><item><title>设计模式不是用来背的：把单例、工厂、Builder 串成一条进化时间线</title><link>http://mp.weixin.qq.com/s?__biz=MjM5NjAxMzk4NA==&amp;mid=2247497289&amp;idx=1&amp;sn=cb379897a4fe748a48553c11f907cb34&amp;chksm=a7adffb179e428ebd0a381eee7c48bb8ad1bae3a0b5b104a83eaa8fc6a3d39258a5c3a2ac2c4&amp;scene=0&amp;xtrack=1#rd</link><description><![CDATA[如果把你写代码这几年剪成一支 vlog，大概会有一个反复出现的镜头：手指一抖，new 一下；上面挂个指针，下面顺手加个注释；心里默念一句：先跑起来，真出事再说。很长一段时间，大家都这么写。那会儿 C]]></description><author>everystep</author><pubDate>Sun, 14 Dec 2025 07:00:00 +0800</pubDate></item><item><title>原型模式：当 new 都不好使的时候，如何优雅地复制对象？</title><link>http://mp.weixin.qq.com/s?__biz=MjM5NjAxMzk4NA==&amp;mid=2247497288&amp;idx=1&amp;sn=a093c8556c86ef076af0660ffd13c182&amp;chksm=a7a160c81603a0d5cb2306511a5b5a0cc276ad1662b36618cfc4d4853b332000a7c7d024c72b&amp;scene=0&amp;xtrack=1#rd</link><description><![CDATA[我在 C++ 老项目里见过一种熟悉的“心态崩溃瞬间”。大家都在赶上线，日志刷得飞起，CI 一片绿。 这时候产品在群里轻描淡写来一句：“这套不错，同款再来一份，改两项就行。”外行看：两项配置，小事一桩。]]></description><author>everystep</author><pubDate>Sat, 13 Dec 2025 07:00:00 +0800</pubDate></item><item><title>别再让新人背参数顺序了：用 Builder 把复杂对象交给“装修队长”</title><link>http://mp.weixin.qq.com/s?__biz=MjM5NjAxMzk4NA==&amp;mid=2247497222&amp;idx=1&amp;sn=0846de602fa98d23772efe4782793e29&amp;chksm=a7dc1e38dc92a9d70d2a124b6993e900cee15edd0be406e023a870cfa6e733eb52690f9b71d1&amp;scene=0&amp;xtrack=1#rd</link><description><![CDATA[如果说抽象工厂是"一整套家居套餐一起换皮"， 那 Builder 更像是：请了个懂行的装修队长。户型早就定好了， 你只管说：墙怎么刷、灯怎么装、地板用什么材质。工厂帮你定户型， Builder 盯着装]]></description><author>everystep</author><pubDate>Fri, 12 Dec 2025 07:00:00 +0800</pubDate></item><item><title>单例是真香还是原罪？用 C++ 把这 3 个误会说清楚</title><link>http://mp.weixin.qq.com/s?__biz=MjM5NjAxMzk4NA==&amp;mid=2247497214&amp;idx=1&amp;sn=ad9f0fb1228d5fa28d0caa581b652f8c&amp;chksm=a7d0cd7e52f4e826938fc786fbda9a6f78b0aaae8064d3c170bf077c4b41975133dd0a6b0716&amp;scene=0&amp;xtrack=1#rd</link><description><![CDATA[在所有设计模式里，如果要评个「又常见、又容易被骂」的前三名，单例肯定占一个坑。写过几年 C++ 的人，多半都见过类似的吐槽：所谓单例，就是给全局变量穿了件西装。这话听着有点阴阳怪气，但也不算冤。要把单]]></description><author>everystep</author><pubDate>Thu, 11 Dec 2025 07:00:00 +0800</pubDate></item><item><title>这 3 个信号一出现，你就该用抽象工厂而不是一堆散落的工厂方法了</title><link>http://mp.weixin.qq.com/s?__biz=MjM5NjAxMzk4NA==&amp;mid=2247497213&amp;idx=1&amp;sn=c0d7dd03bb71a78ae7fe618aa999709d&amp;chksm=a77303794d1c4fe9a846962a1eddef325bad30f9051dbc5152fb40403a8fe8448f4f7d07635e&amp;scene=0&amp;xtrack=1#rd</link><description><![CDATA[如果说工厂方法是"把简单工厂长胖的那摊事，按场景拆成一排小工厂"， 那抽象工厂大概就是：不光要决定“造哪种椅子”， 还要顺手把同一风格的桌子、沙发、床头柜一起配齐。一句话：我不是只卖一把椅子，而是卖一]]></description><author>everystep</author><pubDate>Wed, 10 Dec 2025 07:00:00 +0800</pubDate></item><item><title>这 3 个信号一出现，你就该用工厂方法而不是简单工厂了</title><link>http://mp.weixin.qq.com/s?__biz=MjM5NjAxMzk4NA==&amp;mid=2247497218&amp;idx=1&amp;sn=9ca69631f6b2c0c53313f450250b79ed&amp;chksm=a7ae81f6175ae1ec4d13058d9615e908d5333b0987f5e3d80529f7e2876c3f309cb7213d1363&amp;scene=0&amp;xtrack=1#rd</link><description><![CDATA[如果说简单工厂是"给满地乱飞的 new 搞个前台窗口"， 那工厂方法大概就是：把那个前台拆成一排窗口， 每个窗口只接待自己那一类客人， 具体怎么服务，交给各个窗口自己决定。很多团队都是这样一路走过来的]]></description><author>everystep</author><pubDate>Tue, 09 Dec 2025 07:00:00 +0800</pubDate></item><item><title>用现代 C++ 从零构建一个 mini-Redis：一个真能写进简历的硬核后台项目</title><link>http://mp.weixin.qq.com/s?__biz=MjM5NjAxMzk4NA==&amp;mid=2247497218&amp;idx=2&amp;sn=722882adea26607356bdd6fa380268d1&amp;chksm=a7bb8d8708393671be65d66d6f8f3781ed836d7367ecb8ac744d37896997703f7f2516231ce0&amp;scene=0&amp;xtrack=1#rd</link><description><![CDATA[C++ 程序员的成长之路，大概率是这么铺的：手里捧着那本比砖头还沉的《C++ Primer》，从指针硬啃到 RAII，从模板死磕到右值引用。后来 lambda 来了，std::async 来了，你咬咬]]></description><author>everystep</author><pubDate>Tue, 09 Dec 2025 07:00:00 +0800</pubDate></item><item><title>这 3 个信号一出现，你就该用简单工厂替代到处乱 new 了</title><link>http://mp.weixin.qq.com/s?__biz=MjM5NjAxMzk4NA==&amp;mid=2247497208&amp;idx=1&amp;sn=691ddea4a7d4d84627fed057e3795d70&amp;chksm=a72d61172412d2aefbafa0ade308bf3d1b69c2701b0f61368bf39b7153a896a5875697f1000c&amp;scene=0&amp;xtrack=1#rd</link><description><![CDATA[如果说单例是"给全局变量穿西装"，那简单工厂大概就是"给满地乱飞的 new 搞个前台窗口"。老一代 C / C++ 项目里，new（或者更早的 malloc）就像是空气：想要一个对象？new 一下；想]]></description><author>everystep</author><pubDate>Mon, 08 Dec 2025 07:00:00 +0800</pubDate></item><item><title>真正的工程师，连“字符串”都要重新设计</title><link>http://mp.weixin.qq.com/s?__biz=MjM5NjAxMzk4NA==&amp;mid=2247497185&amp;idx=1&amp;sn=0d7484a8a5858f152bd2e7a7db1b820b&amp;chksm=a7954b5f22738b5bfa46b579099bdbce7510fa3ed02c7cd9e37f69438064b19fefbe66267b19&amp;scene=0&amp;xtrack=1#rd</link><description><![CDATA[在我做面试官的这些年里，只要聊到 C++，字符串几乎是逃不过去的一关。一开始大家还在认真比较 std::string 和 char*，讨论谁更安全、谁更高效，聊到差不多的时候，我一般会顺手把话题往旁边]]></description><author>everystep</author><pubDate>Sun, 07 Dec 2025 07:00:00 +0800</pubDate></item><item><title>搞清楚栈和堆之后，很多鬼畜 bug 瞬间变得合情合理</title><link>http://mp.weixin.qq.com/s?__biz=MjM5NjAxMzk4NA==&amp;mid=2247497181&amp;idx=1&amp;sn=e4321b4b573fd87ecf24c8573dbece95&amp;chksm=a74b9161760d22f80a8ae6e82acd004e495860284a328b6cc4799ee44d8c027845bc58d000e6&amp;scene=0&amp;xtrack=1#rd</link><description><![CDATA[如果你已经能写出这样的代码：void foo() {    int x = 42;}int* bar() {    int y = 10;    return &y;  // 这样写总觉得哪儿怪怪的}]]></description><author>everystep</author><pubDate>Sat, 06 Dec 2025 07:00:00 +0800</pubDate></item><item><title>把指针学明白，你的 C++ 职业寿命会变长</title><link>http://mp.weixin.qq.com/s?__biz=MjM5NjAxMzk4NA==&amp;mid=2247497177&amp;idx=1&amp;sn=c340e684c5c23d49a179e81feb09f225&amp;chksm=a78f3d78b3e5f46a08d0c6eaf73ea991e3900e48d04590fe7f682bd180929faf806ab7c2926f&amp;scene=0&amp;xtrack=1#rd</link><description><![CDATA[先从一个不少人都亲身经历过的修罗场说起。你写完人生第一段 C++ 代码。心情还挺美：「不就几行嘛，能出啥事？」你点下运行。屏幕一黑，程序当场去世，临走前留下一行冷冰冰的字：Segmentation f]]></description><author>everystep</author><pubDate>Fri, 05 Dec 2025 07:00:00 +0800</pubDate></item><item><title>把 init/free 写进类型，编译器替你收尾。</title><link>http://mp.weixin.qq.com/s?__biz=MjM5NjAxMzk4NA==&amp;mid=2247497172&amp;idx=1&amp;sn=e6a55fd76261c39da4a26aaf68ebd51c&amp;chksm=a76844160c1ac110a42fa2b76d4bc464cfb54914c54300ed2edf8f708d394502f282bfaeaf39&amp;scene=0&amp;xtrack=1#rd</link><description><![CDATA[在 C 里，你的人生基本被两件小事反复支配：init 和 free。写着写着，一个 struct 又长出两个字段；某个 malloc 写完，心想“等会儿再补个 free”；函数多加了一个早退分支，re]]></description><author>everystep</author><pubDate>Thu, 04 Dec 2025 07:00:00 +0800</pubDate></item><item><title>我天，C++ 已沦为老二。。</title><link>http://mp.weixin.qq.com/s?__biz=MjM5NjAxMzk4NA==&amp;mid=2247497164&amp;idx=1&amp;sn=a88e79a64bdce531abb291eaee238177&amp;chksm=a74d21ca81f820e6b9d068b8dec58735789161f71836a93d41d8a676df4141f90e547a8c4cb7&amp;scene=0&amp;xtrack=1#rd</link><description><![CDATA[最近技术圈里的“AI焦虑”搞得人心惶惶，“大模型”、“替代程序员”等词频频刷屏。很多人疑问：浪潮之下，C++到底要不要掌握AI大模型能力？不会饭碗还能保住吗？其实大部分人还在死守老一套，而身边有的同事]]></description><author>everystep</author><pubDate>Wed, 03 Dec 2025 07:00:00 +0800</pubDate></item><item><title>为什么 Java/Python 不需要头文件，而 C/C++ 离不开它？</title><link>http://mp.weixin.qq.com/s?__biz=MjM5NjAxMzk4NA==&amp;mid=2247497124&amp;idx=1&amp;sn=177de4689749f1b8731585ddd586000c&amp;chksm=a7a284013faadd81daf5ea6109a05bff2c288135df57ac2266f14651a3ad18b5da69ee5b0ef7&amp;scene=0&amp;xtrack=1#rd</link><description><![CDATA[写过一段时间 C 之后，你大概已经习惯了这样的画面：文件一开头摆着一堆“函数原型”，后面某个地方才是完整的函数体；或者某个 .h 里全是“函数名字和参数列表”，真正的实现藏在别的 .c / .cpp]]></description><author>everystep</author><pubDate>Tue, 02 Dec 2025 07:00:00 +0800</pubDate></item><item><title>如果你还把 C++ 当“加强版 C”，这篇类型系统一定会吓你一跳</title><link>http://mp.weixin.qq.com/s?__biz=MjM5NjAxMzk4NA==&amp;mid=2247497113&amp;idx=1&amp;sn=0265f77df977ed9d16a6af2d099c73c4&amp;chksm=a78507df94925a422d02aa9733b8c1b53a61907d4187be6d7f81de470c115cdda1554336b879&amp;scene=0&amp;xtrack=1#rd</link><description><![CDATA[C++ 从一开始就是“带有强烈类型观念的 C 语言”。你在语法层面看到的是 int、double、std::string、std::vector<int> 这些名字，在编译器眼里，它们背后是一整套关于]]></description><author>everystep</author><pubDate>Mon, 01 Dec 2025 07:00:00 +0800</pubDate></item><item><title>写多线程总是心里没底？看看 C/C++11 标准到底保了你什么</title><link>http://mp.weixin.qq.com/s?__biz=MjM5NjAxMzk4NA==&amp;mid=2247497108&amp;idx=1&amp;sn=552ded6e0ddd6856caec4b5365fbd158&amp;chksm=a7a8d8c68e788d9ba2364399e1a41f4f8df2ddd2c5a39a3f2172324b33dcc90940e4c9be28e2&amp;scene=0&amp;xtrack=1#rd</link><description><![CDATA[写多线程 C/C++ 代码时，真正让人不安的，往往不是 Bug 本身，而是：你很难说清楚，眼前这个结果到底是“语言保证的”，还是“刚好没出事”。你大概听说过数据竞争、顺序一致性、happens-bef]]></description><author>everystep</author><pubDate>Sun, 30 Nov 2025 07:00:00 +0800</pubDate></item><item><title>从 C/C++、Java 到 Go，聊聊并发语义背后的取舍</title><link>http://mp.weixin.qq.com/s?__biz=MjM5NjAxMzk4NA==&amp;mid=2247497104&amp;idx=1&amp;sn=6bc9c307f3e1977ead4aa1e26ab75f54&amp;chksm=a76b76039a3c2c285e71e7e51ca1398d2ccf1e271ef7a75294e74b1aaa84d9d1e7c07e6e2152&amp;scene=0&amp;xtrack=1#rd</link><description><![CDATA[你有没有遇到过这种场景：两个线程配合干活，一个负责“准备数据”，另一个负责“等准备好就开干”。单元测试里一切正常，上了线却偶尔读到一半更新的配置、莫名其妙崩溃。直觉上你会想：既然这些 Bug 都和乱序]]></description><author>everystep</author><pubDate>Sat, 29 Nov 2025 07:00:00 +0800</pubDate></item><item><title>多核与内存模型：一些写多线程代码时的零碎笔记</title><link>http://mp.weixin.qq.com/s?__biz=MjM5NjAxMzk4NA==&amp;mid=2247497099&amp;idx=1&amp;sn=28acd356819f65ad213e168a28c511eb&amp;chksm=a76bd95e4c09f8351e4c1bdf118e8f94bd59d552454f35ea4a07eb010195129e5526c0581529&amp;scene=0&amp;xtrack=1#rd</link><description><![CDATA[你有没有过这样的经历？写了一段多线程代码，逻辑查了十遍，单元测试也跑得溜溜的。可一到生产环境，或者在大压力测试下，它就开始出现一些莫名其妙的错误。你要去抓它吧，它又消失了；你一转身，它又换个方式出现。]]></description><author>everystep</author><pubDate>Thu, 27 Nov 2025 23:14:30 +0800</pubDate></item><item><title>C++ 匿名命名空间详解：优雅地隐藏实现细节</title><link>http://mp.weixin.qq.com/s?__biz=MjM5NjAxMzk4NA==&amp;mid=2247497095&amp;idx=1&amp;sn=421f24e90ab48354152a5072d783acdf&amp;chksm=a73243f9a2fccd2a414f610363fac7d2891c31c5c43658540241fe1788d1810deb0eb7f15e85&amp;scene=0&amp;xtrack=1#rd</link><description><![CDATA[在 C++ 开发中，我们经常面临一个问题：如何确保当前文件中的函数或变量不污染全局作用域，且不与其他文件中的同名符号发生冲突？1. 场景还原：名字冲突的烦恼假设我们正在开发一个简单的程序，有两个源文件]]></description><author>everystep</author><pubDate>Wed, 26 Nov 2025 21:20:31 +0800</pubDate></item><item><title>大模型越强，我越常问自己：哪一部分工作最容易被它取代？</title><link>http://mp.weixin.qq.com/s?__biz=MjM5NjAxMzk4NA==&amp;mid=2247497081&amp;idx=1&amp;sn=c83906b0c5ea53cd8ec34e44ff3c39be&amp;chksm=a760f4c96dd80986cb583e417f1c931e45237253aa422bc65ae789811c0be19bf1ef7af850b4&amp;scene=0&amp;xtrack=1#rd</link><description><![CDATA[今天早上看到 Andrej Karpathy 发的一段短文，重新把我拉回到一个老问题上：到底哪些工作，会被 AI 做掉，哪些工作，依然要靠人？他用一个很简单的视角来回答：与其纠结“AI 理解力强不强”]]></description><author>everystep</author><pubDate>Mon, 17 Nov 2025 22:16:03 +0800</pubDate></item><item><title>工作速度X10，不靠鸡血：靠的是“可验证的下一步”</title><link>http://mp.weixin.qq.com/s?__biz=MjM5NjAxMzk4NA==&amp;mid=2247497077&amp;idx=1&amp;sn=777ff824289e9b593806ce045cf802ea&amp;chksm=a71a37d4628592a17ddd33c8b15464e4072185e8461149b018ebb93d22fca1c59c57dfe3decf&amp;scene=0&amp;xtrack=1#rd</link><description><![CDATA[我第一次接触软件开发，是在很小的时候。那时我用的是图形化积木式编程，只记得自己能做一些简单的小游戏。技术细节早已忘光，但回想起来，我确实学到过基础的逻辑和流程控制。不过没多久就放弃了，之后几年几乎与编]]></description><author>everystep</author><pubDate>Sat, 15 Nov 2025 12:39:43 +0800</pubDate></item><item><title>最近，C++的招聘市场已经疯掉了。。。</title><link>http://mp.weixin.qq.com/s?__biz=MjM5NjAxMzk4NA==&amp;mid=2247497071&amp;idx=1&amp;sn=2e9ff358a51e9f0075cad5afc2853861&amp;chksm=a724edd05a7858ddb86d3e40da9f621ada0b6b12ea04c251747dee649f02d9833efc02bff4ff&amp;scene=0&amp;xtrack=1#rd</link><description><![CDATA[说真的，这两年看着身边一个个搞C++、Java、前端、数据、架构的开始卷大模型，挺唏嘘的。大家最开始都是写接口、搞Spring Boot、连数据库、配Redis，稳稳当当过日子。结果GPT、DeepS]]></description><author>everystep</author><pubDate>Tue, 11 Nov 2025 07:00:00 +0800</pubDate></item><item><title>回到1995：我用奔腾133和一堆文件夹，写代码的那些年</title><link>http://mp.weixin.qq.com/s?__biz=MjM5NjAxMzk4NA==&amp;mid=2247497050&amp;idx=1&amp;sn=acf65c32267773323d4a89eac1644ad5&amp;chksm=a76b6c4e53b2370ff465fefb996d9ec0e9ffac78dbbe650c5617565dcea6b5429e8b7b427e5b&amp;scene=0&amp;xtrack=1#rd</link><description><![CDATA[想象一下这个画面：凌晨 3 点，你坐在一台奔腾 133 的电脑前，盯着屏幕上密密麻麻的文件夹——项目_最终版、项目_最终版2、项目_真正的最终版、项目_这次是真的最终版_我发誓……你深吸一口气，准备打]]></description><author>everystep</author><pubDate>Fri, 10 Oct 2025 22:04:27 +0800</pubDate></item><item><title>从零实现 Git，面试降维打击</title><link>http://mp.weixin.qq.com/s?__biz=MjM5NjAxMzk4NA==&amp;mid=2247497041&amp;idx=1&amp;sn=73729e18a6edc12925f1badf76b07c94&amp;chksm=a7d6bd98c3647322313b29b83f929719d7d92ea18f988ffc23ec4ac346bd07875d80ccdd6baa&amp;scene=0&amp;xtrack=1#rd</link><description><![CDATA[简历上写“精通 Git”，你真的“精通”吗？你每天用 git pull、git push、git commit，命令敲得飞起，感觉自己早已驾轻就熟。但午夜梦回，你是否也曾被这些场景惊出一身冷汗：面试官]]></description><author>everystep</author><pubDate>Mon, 06 Oct 2025 22:55:29 +0800</pubDate></item><item><title>解耦神器！深入解析“责任链模式”，让你的模块像乐高一样自由插拔</title><link>http://mp.weixin.qq.com/s?__biz=MjM5NjAxMzk4NA==&amp;mid=2247497035&amp;idx=1&amp;sn=2c59b4b307f5d21ceea38d43a727efe4&amp;chksm=a7c3cb1f1b4adf12cc45a3ed1e8d4565979f3d22008a4c171f79d638d11f6a18623e0e023e0d&amp;scene=0&amp;xtrack=1#rd</link><description><![CDATA[你有没有过这样的经历？新买的笔记本电脑出了点问题，你兴冲冲地跑到客服中心，结果发现解决一个问题，简直像在“闯关”。**前台接待 (L1)**：你先找到前台小姐姐，她会帮你解决一些“重启试试”、“是不是]]></description><author>everystep</author><pubDate>Thu, 18 Sep 2025 23:49:13 +0800</pubDate></item><item><title>告别“复制粘贴”：用模板方法模式，优雅地为流程“立规矩”</title><link>http://mp.weixin.qq.com/s?__biz=MjM5NjAxMzk4NA==&amp;mid=2247497028&amp;idx=1&amp;sn=7b1a91ed4a90a02f2166c9ca783bd520&amp;chksm=a7009eca54133c4affb81ced2597ab011838f59d60f07abef00abee114ccd04b233d9ec0b930&amp;scene=0&amp;xtrack=1#rd</link><description><![CDATA[你有没想过，为什么麦当劳的巨无霸，无论你在哪个城市吃，味道都一模一样？而你妈（或者你）做的红烧肉，每次味道都飘忽不定？秘密就在于一套雷打不动的“标准作业流程”（SOP）。在软件世界里，这套 SOP 就]]></description><author>everystep</author><pubDate>Sun, 14 Sep 2025 18:32:27 +0800</pubDate></item><item><title>最近学了个新招，让我的 if-else 清爽了不少</title><link>http://mp.weixin.qq.com/s?__biz=MjM5NjAxMzk4NA==&amp;mid=2247497017&amp;idx=1&amp;sn=2e9259176a6163fe962b62456910559f&amp;chksm=a7d8fba0665fd5a62d31d7964f2c58440af0042b77d4fd7990427c6e9750c541372780f22b41&amp;scene=0&amp;xtrack=1#rd</link><description><![CDATA[双十一血拼，你终于在购物车里塞满了宝贝，来到了最后的“决战”——支付页面。这时候，屏幕上是不是会跳出一大堆选项，让你眼花缭乱？信用卡大法 💳：输入一长串数字，体验“数字消失”的快感。支付宝/微信扫码]]></description><author>everystep</author><pubDate>Sat, 13 Sep 2025 23:16:51 +0800</pubDate></item><item><title>再探 C++ 构造函数：我们真的了解对象的“第一声啼哭”吗？</title><link>http://mp.weixin.qq.com/s?__biz=MjM5NjAxMzk4NA==&amp;mid=2247497009&amp;idx=1&amp;sn=084dd021852588ec1e3babaf6675d681&amp;chksm=a75da9931f8e298b4cd5fed19a4d6c49eb3290017f225cd555e1bb65b657673d12d09bc658e3&amp;scene=0&amp;xtrack=1#rd</link><description><![CDATA[上一回，我们围观了 struct 这个只会装钱的“憨憨钱包”，如何进化成 class 这个会自己管钱的“智能银行账户”。我们还学会了用构造函数，在“开户”的一瞬间，就把客户信息安排得明明白白。但你以为]]></description><author>everystep</author><pubDate>Thu, 11 Sep 2025 21:40:04 +0800</pubDate></item><item><title>想彻底看透 class，我们得先回到 C 语言的 struct</title><link>http://mp.weixin.qq.com/s?__biz=MjM5NjAxMzk4NA==&amp;mid=2247497003&amp;idx=1&amp;sn=0c71d4a7647ddf24e4c873ad60c827be&amp;chksm=a7c5a2830c69c8d51e61c0231fa1ab60145e3a3d753a49a968337687a78e3ac8771007ee76a7&amp;scene=0&amp;xtrack=1#rd</link><description><![CDATA[欢迎来到 C++ 面向对象编程（OOP）的第一站！🚀 在咱们聊那些“高大上”的封装、继承和多态之前，得先挖挖根儿，搞明白 C++ 最核心的玩意儿——“对象”，到底是怎么来的。忘掉那些让人头疼的游戏角色]]></description><author>everystep</author><pubDate>Wed, 10 Sep 2025 22:35:28 +0800</pubDate></item><item><title>C++ 字符串的“零拷贝”往事：string_view 诞生前的江湖</title><link>http://mp.weixin.qq.com/s?__biz=MjM5NjAxMzk4NA==&amp;mid=2247496997&amp;idx=1&amp;sn=3e1e430c6cab0f1451e25e741b2f9940&amp;chksm=a7e1b90e6bf71659cbc9fb58701cd3e51ab894156153fc26b98a80662c06cd741dc8494fabf8&amp;scene=0&amp;xtrack=1#rd</link><description><![CDATA[C++17 空降了一位“武林盟主”——std::string_view，一统字符串视图的江湖。它用几乎零成本的“内力”，化解了函数间传递字符串时的昂贵拷贝，让无数 C++ 程序员如释重负，感觉“泰裤辣]]></description><author>everystep</author><pubDate>Tue, 09 Sep 2025 21:52:42 +0800</pubDate></item><item><title>为什么说 std::string 不只是一个“更好用的 char*”？</title><link>http://mp.weixin.qq.com/s?__biz=MjM5NjAxMzk4NA==&amp;mid=2247496992&amp;idx=1&amp;sn=425823a1f506c521ee476803d226465d&amp;chksm=a7832f971eededaa9d121f38cd41f359446286ecec54c1352220d948c9df222eaed965f62240&amp;scene=0&amp;xtrack=1#rd</link><description><![CDATA[刚从 C 语言 char* 的“刀耕火种”时代爬出来的 C++ 新手，第一次看到 std::string 时，大概都会热泪盈眶，感觉像是“终于活进了文明社会” 😌。这位“管家”实在是太能干了：自动管理]]></description><author>everystep</author><pubDate>Mon, 08 Sep 2025 07:00:00 +0800</pubDate></item><item><title>除了 char* 和 std::string，C++ 程序员还应该了解第三种字符串。</title><link>http://mp.weixin.qq.com/s?__biz=MjM5NjAxMzk4NA==&amp;mid=2247496983&amp;idx=1&amp;sn=a1056399b380438f57e45d3c84155d44&amp;chksm=a72b2ed9cfe157691d0780189701f1c219c5a4ffaf44d53abf681f1495bf966edbac3507eadc&amp;scene=0&amp;xtrack=1#rd</link><description><![CDATA[C++ 程序员在面试时，是不是经常被拉着聊 std::string 和 C 风格字符串 (char*) 的爱恨情仇？😅 说实话，这话题的“盘”都快被大家“包浆”了。但真正的高手过招，早就把目光投向了]]></description><author>everystep</author><pubDate>Sun, 07 Sep 2025 13:38:12 +0800</pubDate></item><item><title>C++ Core Guidelines 解读</title><link>http://mp.weixin.qq.com/s?__biz=MjM5NjAxMzk4NA==&amp;mid=2247496972&amp;idx=1&amp;sn=61e24ba4bbbafab0530a5a8f1dcbf359&amp;chksm=a784218b7beb0f05bc5ddd04f20cb00637da3d004af58ea14857665283f4c701f9e119ec5c0b&amp;scene=0&amp;xtrack=1#rd</link><description><![CDATA[欢迎来到 C++ Core Guidelines 解读专栏！🚀在这个专栏里，我们想用“人话”和看得懂的代码，带你一起深入探索由 C++ 之父 Bjarne Stroustrup 和 Herb Sutt]]></description><author>everystep</author><pubDate>Thu, 04 Sep 2025 22:46:32 +0800</pubDate></item><item><title>explicit：一个被低估的 C++ 防御性编程利器</title><link>http://mp.weixin.qq.com/s?__biz=MjM5NjAxMzk4NA==&amp;mid=2247496966&amp;idx=1&amp;sn=247ca6f4ed2f432dcab8568e7cb9144b&amp;chksm=a759f6f284d137529471d72a20135623b0951b9b1ca7f25a969614c2a9070fa0edbdfe35cd1a&amp;scene=0&amp;xtrack=1#rd</link><description><![CDATA[在 C++ 的世界里，编译器常常像一个“热心肠”的朋友。它总想帮你把事情搞定，有时候甚至会“自作主张”，在你没有明确要求的情况下，偷偷地帮你进行类型转换。这种行为，就是我们常说的**隐式类型转换 (I]]></description><author>everystep</author><pubDate>Sun, 17 Aug 2025 22:44:02 +0800</pubDate></item><item><title>C++17 如何让编译器，帮你检查“空指针”？</title><link>http://mp.weixin.qq.com/s?__biz=MjM5NjAxMzk4NA==&amp;mid=2247496960&amp;idx=1&amp;sn=a1b90fa77aaf9cd572cddfa1efafab4f&amp;chksm=a7e6825a0a50726d9230d209b138578d9832f39528ed3d419ae909e3e1dd9eb88bd6006d9ff3&amp;scene=0&amp;xtrack=1#rd</link><description><![CDATA[你的 C++ 代码里，是否也藏着这样的“定时炸弹”？💣一个返回指针的函数，你敢保证每次都检查了 nullptr 吗？一个查找函数，失败时返回 -1，你敢说它永远不会和真实的业务数据 -1 混淆吗？这些]]></description><author>everystep</author><pubDate>Sat, 16 Aug 2025 11:57:36 +0800</pubDate></item><item><title>超越“是否调用构造函数”：new/delete与malloc/free的本质差异与陷阱</title><link>http://mp.weixin.qq.com/s?__biz=MjM5NjAxMzk4NA==&amp;mid=2247496959&amp;idx=1&amp;sn=4cac08e8fa7f3efd9d68451400df4c02&amp;chksm=a711896202354d9fe616be86a467595367d96fef65e93e162f2b413e32f5971171dd24cd3719&amp;scene=0&amp;xtrack=1#rd</link><description><![CDATA[朋友，欢迎光临 C++ 这家高级餐厅！在这里，我们不仅仅是填饱肚子（获取内存），我们追求的是精致的用餐体验，每一道菜（对象）从准备到上桌，再到餐后清理，都充满了艺术感。想象一下，你想点一道招牌菜“红烧]]></description><author>everystep</author><pubDate>Thu, 14 Aug 2025 21:39:48 +0800</pubDate></item><item><title>为了重载 +，C++ 之父曾把指针“关进笼子”</title><link>http://mp.weixin.qq.com/s?__biz=MjM5NjAxMzk4NA==&amp;mid=2247496953&amp;idx=1&amp;sn=02c605fa0888c1ff2d7dfd504e996e48&amp;chksm=a715f53793db3fbba4465f27d223974a85e4455af029bd0888ed1e0ed269073bd616f417cfc2&amp;scene=0&amp;xtrack=1#rd</link><description><![CDATA[把时间拨回 1982 年，Bjarne 正琢磨怎么给 C 语言加点“仙气”。他盯上了最顺眼的筋斗云：要是能让自定义类型也用 +、-、* 耍帅，那写代码不就成念咒了吗？于是，他先拿“三维向量”开刀，打算]]></description><author>everystep</author><pubDate>Wed, 13 Aug 2025 22:48:58 +0800</pubDate></item><item><title>C++17 的这个“口袋”，为什么比 variant 灵活，却又比 void* 靠谱？</title><link>http://mp.weixin.qq.com/s?__biz=MjM5NjAxMzk4NA==&amp;mid=2247496935&amp;idx=1&amp;sn=c06f8f19c441b4e941c2a6199aa9c919&amp;chksm=a7f2dfaf037e968189898478fff5f283ed76181b92e39675d2b092f642ae5807d46a0975c5c5&amp;scene=0&amp;xtrack=1#rd</link><description><![CDATA[写代码时，咱们最喜欢的就是“一个萝卜一个坑”，一个 int 配一个 int，一个 string 配一个 string，清清楚楚，编译器看了都说好。但总有那么些时候，生活会给你点“惊喜” 😵。比如你正在]]></description><author>everystep</author><pubDate>Sat, 09 Aug 2025 22:53:46 +0800</pubDate></item><item><title>聊聊 C++17 的 std::variant：一个更安全的 union</title><link>http://mp.weixin.qq.com/s?__biz=MjM5NjAxMzk4NA==&amp;mid=2247496927&amp;idx=1&amp;sn=7a05b4405a1b7bebc99d18a9caf3f70d&amp;chksm=a70a8e7ceee9a7278fd14790190a2c4b244e59049bae0edaf5b1f9695dcacd861ffbf183bd0b&amp;scene=0&amp;xtrack=1#rd</link><description><![CDATA[你是否也曾被这样一个问题困扰：如何在一个变量里，安全地存放几种完全不同的类型？🤔也许你想起了 C 语言中的老朋友 union，它承诺能做到这一点，但却像一个没有说明书的“盲盒” 🎁。你往里面放了个整数]]></description><author>everystep</author><pubDate>Tue, 05 Aug 2025 23:38:19 +0800</pubDate></item><item><title>它终结了 printf 与 cout 的内战：std::format 的前世今生</title><link>http://mp.weixin.qq.com/s?__biz=MjM5NjAxMzk4NA==&amp;mid=2247496890&amp;idx=1&amp;sn=a1c8cbf23d4f80199e891b3d092848f1&amp;chksm=a7039983ed6ae4981a2611928d1bfb66f8b91b6e13ad32dc6b9d8865ade1bf1f884005f8fda4&amp;scene=0&amp;xtrack=1#rd</link><description><![CDATA[你的 C++ 编程生涯中，一定有那么几个瞬间让你抓狂 🤯：当你小心翼翼地写下 printf("Value: %f", my_double);，结果忘了 my_double 其实是 int，导致程序在客]]></description><author>everystep</author><pubDate>Thu, 31 Jul 2025 22:31:34 +0800</pubDate></item><item><title>别再CV大法了！一个std::span，优雅搞定所有C++数组传参</title><link>http://mp.weixin.qq.com/s?__biz=MjM5NjAxMzk4NA==&amp;mid=2247496881&amp;idx=1&amp;sn=429284293d42a14fb1a9c96ca756e684&amp;chksm=a7b166e3034aedd5ccb17c5a05f56e61cf792f9b8df066787857035944df95736a1e3ad37945&amp;scene=0&amp;xtrack=1#rd</link><description><![CDATA[你一定经历过这样的“代码噩梦”：你写了一个超棒的函数，能完美处理 std::vector<int>。你的同事看了赞不绝口，然后反手就丢给你一个 C 风格的老式数组 int[]，问：“这个能用吗？” 🥶]]></description><author>everystep</author><pubDate>Wed, 30 Jul 2025 21:05:19 +0800</pubDate></item><item><title>字符串的救赎：从 const string&amp; 到 string_view 的演进史</title><link>http://mp.weixin.qq.com/s?__biz=MjM5NjAxMzk4NA==&amp;mid=2247496871&amp;idx=1&amp;sn=266cec72868c0322102ab034a5f229b9&amp;chksm=a7d574ff5f41428ac2b4736c8b33e4644f77faf7b38752d23528b96bf2ebb1c0b1c94482cc20&amp;scene=0&amp;xtrack=1#rd</link><description><![CDATA[在 C++ 的编程世界里，字符串处理是一个永恒的话题。几乎每个程序都离不开它，但长久以来，如何高效、优雅地传递和操作字符串，一直困扰着无数开发者。这不仅仅是技术选型的问题，更是一段充满了血泪与智慧的演]]></description><author>everystep</author><pubDate>Tue, 29 Jul 2025 22:19:27 +0800</pubDate></item><item><title>用现代 C++ 从零构建一个 mini-Redis：一个可以真正写进简历的高质量项目</title><link>http://mp.weixin.qq.com/s?__biz=MjM5NjAxMzk4NA==&amp;mid=2247496853&amp;idx=1&amp;sn=7f1febd2a9cfe02b022c550f10b51a10&amp;chksm=a79441d29af3452fe6c2a76c5d5c5076bcf17514a567e64308efb50d107ead97763e0d8b41db&amp;scene=0&amp;xtrack=1#rd</link><description><![CDATA[你抱着那本比砖头还厚的《C++ Primer》，啃完了上千页的语法，从“RAII”到“右值引用”，从“模板元编程”到 C++23 的新特性，感觉自己无所不能。但一到动真格的时候，瞬间被打回原形：面试官]]></description><author>everystep</author><pubDate>Mon, 28 Jul 2025 22:07:23 +0800</pubDate></item><item><title>从 Boost、Qt 到 C++11，enum class 的诞生，竟是一部血泪史</title><link>http://mp.weixin.qq.com/s?__biz=MjM5NjAxMzk4NA==&amp;mid=2247496839&amp;idx=1&amp;sn=3140d721dd96ad809cedce7846afcaef&amp;chksm=a7c58d7ee69929484fb721ccd25d3ac6f3c17345a1ad79749a3da2799080a7c659208748d3f8&amp;scene=0&amp;xtrack=1#rd</link><description><![CDATA[如果你写过有些年头的 C++，大概率遇到过这样的场景：你在一个头文件里开心地定义了一组颜色，又在另一个头文件里定义了交通信号灯的状态。// a.henum Color { Red, Green, Bl]]></description><author>everystep</author><pubDate>Sat, 26 Jul 2025 18:18:12 +0800</pubDate></item><item><title>如何从零构建一个最基础的智能指针？</title><link>http://mp.weixin.qq.com/s?__biz=MjM5NjAxMzk4NA==&amp;mid=2247496829&amp;idx=1&amp;sn=ae65a4469851957b03e29603bc8b3978&amp;chksm=a74ed4df1f6f23813b79208378fdffe5625f9373eb04eb2a06884b0a676047dd33b7b11fc66d&amp;scene=0&amp;xtrack=1#rd</link><description><![CDATA[还在被 new 和 delete 折磨？本文带你亲手终结这场噩梦。我们将从零开始，用最精简的代码，打造一个能自动管理内存的C++智能指针。你是否也曾在深夜，被C++的内存管理折磨得痛不欲生？ 那些该死]]></description><author>everystep</author><pubDate>Sun, 15 Jun 2025 20:50:41 +0800</pubDate></item><item><title>别再无脑#include了！你写的每一行C++代码，可能都在拖慢整个团队！</title><link>http://mp.weixin.qq.com/s?__biz=MjM5NjAxMzk4NA==&amp;mid=2247496619&amp;idx=1&amp;sn=3e4296e4975f65f9a8d3c8d6206a1212&amp;chksm=a7a8273f5d9660a25d6fb7a7e9cfea5e34f081b0d6101307608ed4900ce22760fe21902a123b&amp;scene=0&amp;xtrack=1#rd</link><description><![CDATA[你是否曾经因为修改了一个头文件，就不得不重新编译大半个项目，等到天荒地老？😫 是不是也曾被烦人的"循环依赖"搞得焦头烂额？💔如果我告诉你，有一个 C++ 的小技巧，只需要一行代码，就能轻松斩断这些依赖]]></description><author>everystep</author><pubDate>Tue, 10 Jun 2025 23:24:02 +0800</pubDate></item><item><title>取代C++，中国又一新兴岗位在崛起！这才是程序员未来5年最好的就业方向！</title><link>http://mp.weixin.qq.com/s?__biz=MjM5NjAxMzk4NA==&amp;mid=2247496520&amp;idx=1&amp;sn=b94f632925c23c27b7431d78305542d6&amp;chksm=a76d3a023bfd37e911d912af31bbadf49ea57fadc93d705df81a97ea7f92c18f2978004f1988&amp;scene=0&amp;xtrack=1#rd</link><description><![CDATA[Deepseek全球爆火让AI技术又一次进入了快速发展期！百度、字节、腾讯等等巨头互联网公司，纷纷接入DeepSeek，加速落地AI应用！这让「大模型应用开发工程师」一跃成为炙手可热的岗位！DeepS]]></description><author>everystep</author><pubDate>Fri, 18 Apr 2025 07:00:00 +0800</pubDate></item><item><title>超越传统错误码：C++23 std::expected 如何实现类型安全的错误传递</title><link>http://mp.weixin.qq.com/s?__biz=MjM5NjAxMzk4NA==&amp;mid=2247496512&amp;idx=1&amp;sn=639634d6d04d617b00450366c69a5c11&amp;chksm=a75dfa75212daf2e270ccf120fe2ce9724db891139bb6344f981c0d6a296fa4c7d2ff6ab550d&amp;scene=0&amp;xtrack=1#rd</link><description><![CDATA[嘿，朋友！👋 还记得刚学 C 语言或者刚接触 C++ 那会儿，我们是怎么处理函数可能出错的情况吗？是不是经常看到这样的代码：// 一个尝试做除法的"古老"函数int divide(int a, int]]></description><author>everystep</author><pubDate>Wed, 09 Apr 2025 23:30:00 +0800</pubDate></item><item><title>抽象类/接口类/聚合类区别到底在哪？</title><link>http://mp.weixin.qq.com/s?__biz=MjM5NjAxMzk4NA==&amp;mid=2247496495&amp;idx=1&amp;sn=464aa562d8116304f89ce3a3b442ca1b&amp;chksm=a7bd6b537a10db96f691cc3fcfcc14a2977948814ae2f444efc566d3f8b341cb19afb0e345c7&amp;scene=0&amp;xtrack=1#rd</link><description><![CDATA[嘿，同学！👋 你知道吗？在 C++ 的面试江湖里，抽象类、接口类和聚合类这仨兄弟可是名副其实的“高频考点”！为啥？因为它们仨能很好地考察你对 C++ 面向对象（OOP）的理解深度，以及你是不是真的把]]></description><author>everystep</author><pubDate>Tue, 08 Apr 2025 07:00:00 +0800</pubDate></item><item><title>现代C++建造者模式进化论：从C++98到C++23</title><link>http://mp.weixin.qq.com/s?__biz=MjM5NjAxMzk4NA==&amp;mid=2247496493&amp;idx=1&amp;sn=f844018916e13d16044ca4c1798f9762&amp;chksm=a76216ed701d47577961f63c8d87d19e21deeafa6410d40b1cb7524a2ae6545e2a66031b70eb&amp;scene=0&amp;xtrack=1#rd</link><description><![CDATA[还在为 C++ 对象那 长得令人发指 的构造函数参数列表抓狂吗？🤯 是不是经常在 int hp, int mp, int strength, int faith... 这样的参数“连连看”中迷失自我，]]></description><author>everystep</author><pubDate>Mon, 07 Apr 2025 07:00:00 +0800</pubDate></item><item><title>3分钟彻底搞懂！虚函数和纯虚函数的区别</title><link>http://mp.weixin.qq.com/s?__biz=MjM5NjAxMzk4NA==&amp;mid=2247496437&amp;idx=1&amp;sn=162a93494c022803062fc766af7bd861&amp;chksm=a75fdd877fc747d2c72bc1dc73969140e73e23f6218e621338413c2828c5885977eb1e7bbb89&amp;scene=0&amp;xtrack=1#rd</link><description><![CDATA[朋友们，咱们今天聊的 虚函数 和 纯虚函数，可不是什么边角料知识！这俩哥们儿在 C++ 面向对象编程里，那是 核心中的核心，基础中的基础！有多重要？这么说吧，你去面试 C++ 相关的岗位，十有八九会被]]></description><author>everystep</author><pubDate>Sun, 06 Apr 2025 07:00:00 +0800</pubDate></item><item><title>C++ 面试送命题：虚析构函数答不对，Offer 可能就飞了！</title><link>http://mp.weixin.qq.com/s?__biz=MjM5NjAxMzk4NA==&amp;mid=2247496406&amp;idx=1&amp;sn=90abec5f93cce107108f5454bc7c8f05&amp;chksm=a71ba7d75bbb1e25a29fd46d3e049831e39c2afe8af2a14ec4b3aa3bff4a4ec69f687a95ad85&amp;scene=0&amp;xtrack=1#rd</link><description><![CDATA[嘿，未来的 C++ 大佬们！👋 准备好迎接面试中的一个“经典款”问题了吗？没错，就是那个听起来有点玄乎的“虚析构函数”！别小看它，这玩意儿可是面试官考察你 C++ 基本功、特别是内存管理和多态理解的“]]></description><author>everystep</author><pubDate>Sat, 05 Apr 2025 07:00:00 +0800</pubDate></item><item><title>为什么面试官总爱问emplace_back和push_back的区别？</title><link>http://mp.weixin.qq.com/s?__biz=MjM5NjAxMzk4NA==&amp;mid=2247496395&amp;idx=1&amp;sn=c6357c3edb12f599aa3c67767588b703&amp;chksm=a78045297e18a398b393756bbb90eca294aa9e90a1d06d46f8108463b16dc813d29e79634a9d&amp;scene=0&amp;xtrack=1#rd</link><description><![CDATA[大家好啊！今天我们来聊聊 C++ 标准库容器里一对有趣的成员函数：emplace 系列（比如 emplace_back）和 push_back 系列。这俩哥们儿都能往容器里加东西，但性格和做事方式可差]]></description><author>everystep</author><pubDate>Fri, 04 Apr 2025 07:00:00 +0800</pubDate></item><item><title>什么场景下按值传递比引用更受欢迎？</title><link>http://mp.weixin.qq.com/s?__biz=MjM5NjAxMzk4NA==&amp;mid=2247496327&amp;idx=1&amp;sn=743fc0b30588e8117d55e9734c2ffa76&amp;chksm=a75cba8a785bed14c51354f0adc2e6a530468b71a4cc471aa35fda21f8efb25f44d479989ebe&amp;scene=0&amp;xtrack=1#rd</link><description><![CDATA[话说当年（C++98 及以前），行走江湖的 C++ 大佬们都流传着一条铁律：“小老弟，传自己定义的类型（比如你用 class 或 struct 搞出来的玩意儿），尤其是大块头的，最好用 const 引]]></description><author>everystep</author><pubDate>Thu, 03 Apr 2025 07:00:00 +0800</pubDate></item><item><title>这个C++特性如何用10年时间吃掉所有回调场景？</title><link>http://mp.weixin.qq.com/s?__biz=MjM5NjAxMzk4NA==&amp;mid=2247496309&amp;idx=1&amp;sn=b7af0ecb6048b27d36febe25c21c5032&amp;chksm=a74dbf228c6cb92d684c0ac2ea1bc817455d4a3cd73dd21add4dfbe04a34b921db24fd54ad61&amp;scene=0&amp;xtrack=1#rd</link><description><![CDATA[嘿，你知道吗？在 C++11 正式请来 lambda 这位"大咖"🌟之前，C++ 程序员们为了实现类似的功能，可是费了不少劲呢！"史前时代"🦕：函数对象（Functors）想象一下，在没有 lambd]]></description><author>everystep</author><pubDate>Wed, 02 Apr 2025 07:00:00 +0800</pubDate></item><item><title>为何说 C++ Lambda 是 std::bind 的终结者？</title><link>http://mp.weixin.qq.com/s?__biz=MjM5NjAxMzk4NA==&amp;mid=2247496283&amp;idx=1&amp;sn=2fe776ae24b9797950352637670798f3&amp;chksm=a7dcfc4f57bda7cc819dc2fd4895b1f9a841413f72043cae7f6cd1c02b31b93e8bf272673827&amp;scene=0&amp;xtrack=1#rd</link><description><![CDATA[话说 C++11 带来了 std::bind 这个玩意儿，它其实是 C++98 时代的 std::bind1st 和 std::bind2nd 的"升级版" ✨，甚至在 2005 年左右就通过 TR1]]></description><author>everystep</author><pubDate>Tue, 01 Apr 2025 18:00:00 +0800</pubDate></item><item><title>从编译通过到运行时崩溃：深入剖析 C++ Lambda 默认捕获的致命缺陷</title><link>http://mp.weixin.qq.com/s?__biz=MjM5NjAxMzk4NA==&amp;mid=2247496265&amp;idx=1&amp;sn=04abf0a3159f72eaae003c6b41a770cb&amp;chksm=a7913dc69d79c2b48dd104fa1ca2b988cdb27a2d2ae478f79bf38fb189fe6f59916adaa44eb1&amp;scene=0&amp;xtrack=1#rd</link><description><![CDATA[C++11 给了我们两种看起来很方便的默认捕获模式：[&]（默认按引用捕获）和 [=]（默认按值捕获）。哇，自动挡！是不是感觉编译器瞬间变得超级贴心？🥳 可惜，天下没有免费的午餐，这两种“自动挡”模式]]></description><author>everystep</author><pubDate>Mon, 31 Mar 2025 23:32:00 +0800</pubDate></item><item><title>为什么你永远不该直接删除旧函数？现代C++属性拯救方案大揭秘</title><link>http://mp.weixin.qq.com/s?__biz=MjM5NjAxMzk4NA==&amp;mid=2247496255&amp;idx=1&amp;sn=4551b70246689b6c9b8eb57c842801e5&amp;chksm=a736eb26b2b41a5e559b37a283cd3b7d7928c06fceeca4ca9df08351552f7aeb296800df334c&amp;scene=0&amp;xtrack=1#rd</link><description><![CDATA[🚨 您是否还在为这些问题头疼？▸ API升级后，用户仍在使用旧函数？▸ 代码库中的"毒瘤"函数无法直接删除？▸ 各编译器平台警告机制不统一，跨平台告警困难？💡 废弃属性（[[deprecated]]）]]></description><author>everystep</author><pubDate>Thu, 13 Mar 2025 07:00:00 +0800</pubDate></item><item><title>TypeScript引擎Go移植：编译速度提升10倍</title><link>http://mp.weixin.qq.com/s?__biz=MjM5NjAxMzk4NA==&amp;mid=2247496191&amp;idx=1&amp;sn=db0acbd8429ccf38cb0c5a2338b694f0&amp;chksm=a764ae16340da9b2e9fcbbd92d79dd6a24fc29ad4f77efe4309840a291012eb4dd4b068357cc&amp;scene=0&amp;xtrack=1#rd</link><description><![CDATA[TypeScript作为JavaScript生态中最受欢迎的静态类型系统之一，其主要价值在于为开发者提供卓越的开发体验。然而，随着代码库规模增长，TypeScript现有的基于JavaScript的编]]></description><author>everystep</author><pubDate>Wed, 12 Mar 2025 07:00:00 +0800</pubDate></item><item><title>C++14二进制字面量：位操作错误率降低90%的工程实践</title><link>http://mp.weixin.qq.com/s?__biz=MjM5NjAxMzk4NA==&amp;mid=2247496187&amp;idx=1&amp;sn=b9faef9c4f77b471af6fcba8d8559290&amp;chksm=a7e94b407858e03abc023da8b139e8aed573e9f374c1e2e096792e72154dd42b08139eecf346&amp;scene=0&amp;xtrack=1#rd</link><description><![CDATA[🌟 您是否还在为这些问题头疼？▸ 位运算时需要将二进制心算成十六进制？▸ 看到0xFF时脑内闪过"这是多少位的1来着？"▸ 调试位掩码时眼花缭乱，0和1傻傻分不清？💡 二进制字面量一招解决！C++14]]></description><author>everystep</author><pubDate>Tue, 11 Mar 2025 07:00:00 +0800</pubDate></item><item><title>现代C++工厂模式的六代进化：从C++98到C++23</title><link>http://mp.weixin.qq.com/s?__biz=MjM5NjAxMzk4NA==&amp;mid=2247496126&amp;idx=1&amp;sn=78c224d5d99eb04913655ac919d24efe&amp;chksm=a795622db6519d767bbb879f1e7cdd2556250a868e0bb1d4c801d8f2f6c149b11508986b70bc&amp;scene=0&amp;xtrack=1#rd</link><description><![CDATA[🔍 C++工厂模式：从条件分支到编译期注册的演进之路💡 现代C++开发者面临的工厂模式挑战：如何消除条件分支带来的维护成本？如何实现类型安全的对象创建接口？如何通过编译期优化提升工厂性能？🚀 标准演进]]></description><author>everystep</author><pubDate>Mon, 10 Mar 2025 07:00:00 +0800</pubDate></item><item><title>现代C++单例模式进化论：从C++98到C++23</title><link>http://mp.weixin.qq.com/s?__biz=MjM5NjAxMzk4NA==&amp;mid=2247496073&amp;idx=1&amp;sn=af162e4ca46e55bcf7de1ee7deae8a23&amp;chksm=a7f7b808e1a6197e01d759e7f9c321eac707b9163fcf3499760af0c76f69fe42aec485579bc1&amp;scene=0&amp;xtrack=1#rd</link><description><![CDATA[🔥 C++单例模式：从噩梦到一行代码的进化✨ 您还在为单例实现头疼吗？ 忘掉那些繁琐易错的双检锁吧！现代C++彻底颠覆了传统实现！🚀 从C++98的"线程不安全"到C++23的"完美单例"，见证简洁与]]></description><author>everystep</author><pubDate>Sun, 09 Mar 2025 07:00:00 +0800</pubDate></item><item><title>隐藏在C++14中的编程利器：返回类型还能这么写？</title><link>http://mp.weixin.qq.com/s?__biz=MjM5NjAxMzk4NA==&amp;mid=2247496004&amp;idx=1&amp;sn=160e677ba3af3b3a2406bd8be0c0ff61&amp;chksm=a7376d71a0480a7063f39b5c5ea0ccc153dfdb0a6cfd3f910cf94b69192c51394f881aa8d12a&amp;scene=0&amp;xtrack=1#rd</link><description><![CDATA[🌟 您是否还在为这些问题头疼？▸ 函数模板返回类型写到怀疑人生？▸ decltype(expr1 + expr2)的恐怖嵌套让眼睛疼？▸ 尾置返回类型-> decltype(...)写到手抽筋？💡 函]]></description><author>everystep</author><pubDate>Sat, 08 Mar 2025 18:40:00 +0800</pubDate></item><item><title>90%程序员都忽视的C++内存陷阱，你踩中了吗？</title><link>http://mp.weixin.qq.com/s?__biz=MjM5NjAxMzk4NA==&amp;mid=2247495987&amp;idx=1&amp;sn=497a523e2e248e5520d1e333ec46a0f3&amp;chksm=a725a0133f51c1a1285996f67d0274e0478dd1e2d79824def96cfc7015fada060c0e8de52441&amp;scene=0&amp;xtrack=1#rd</link><description><![CDATA[🔥 C++内存安全：你正在编写的现代语法，可能正在制造定时炸弹！⚠️ 80%开发者不知道的现代C++三大死亡陷阱：🚀 vector自动扩容 → 性能刺客🧩 智能指针类型擦除 → 内存泄漏元凶⏳ Lam]]></description><author>everystep</author><pubDate>Fri, 07 Mar 2025 07:00:00 +0800</pubDate></item><item><title>C++23开发环境速成指南：不改变系统配置，也能体验最新特性</title><link>http://mp.weixin.qq.com/s?__biz=MjM5NjAxMzk4NA==&amp;mid=2247495955&amp;idx=1&amp;sn=990277bec7b2dcf821e585b4f3e9eede&amp;chksm=a704497ad68b72cdae3cd71ea32359144c8fb0ee6c884767188481a14a1c2646ffa277adbd90&amp;scene=0&amp;xtrack=1#rd</link><description><![CDATA[🚀自 C++11 推出以来，C++ 就像坐上了🚀火箭！标准更新📈越来越快，社区每天都有✨新特性爆炸💥！老旧编译器拖后腿？🤯 莫慌！🐳Docker 三大魔法✨帮你瞬间穿越到未来： 💎 环境隔离术 → 自]]></description><author>everystep</author><pubDate>Thu, 06 Mar 2025 07:00:00 +0800</pubDate></item><item><title>C++14变量模板深度解析：如何用变量模板统一常量定义？</title><link>http://mp.weixin.qq.com/s?__biz=MjM5NjAxMzk4NA==&amp;mid=2247495779&amp;idx=1&amp;sn=e6e25cc2915532ca886b8cfe138da010&amp;chksm=a740296acfcd850e14ba88d29897e51c25e544c4abc3d382a1fd021d58a166b20fc480081b7e&amp;scene=0&amp;xtrack=1#rd</link><description><![CDATA[🌟 您是否还在为这些抓狂？▸ 重复定义不同精度的π值？▸ 每次访问模板常量都要穿越::value迷宫？▸ 函数模板的括号地狱折磨手指？💡 变量模板一招破局！C++14带来的编译期黑科技，让常量定义跨越]]></description><author>everystep</author><pubDate>Wed, 05 Mar 2025 07:00:00 +0800</pubDate></item><item><title>一篇文章掌握C++14通用Lambda：让你的代码既简洁又高效</title><link>http://mp.weixin.qq.com/s?__biz=MjM5NjAxMzk4NA==&amp;mid=2247495692&amp;idx=1&amp;sn=3ea3e9fd87ff21eae8389416dbfd38a6&amp;chksm=a756097e9e0bfea73224073e27a9c679f4e1fad6e9af2f0feb7068c5e0e4ecbdc735b632ad71&amp;scene=0&amp;xtrack=1#rd</link><description><![CDATA[🔥你的Lambda还在手动写类型？C++14说：该进化了！🤖✨通用Lambda——让函数对象拥有「自适应超能力」的语法革命！🚀 1行代码=100种可能？🧩 类型自适应 × 代码极简主义 × 模板魔法💡]]></description><author>everystep</author><pubDate>Wed, 26 Feb 2025 22:14:07 +0800</pubDate></item><item><title>3分钟搞懂TCP三次握手</title><link>http://mp.weixin.qq.com/s?__biz=MjM5NjAxMzk4NA==&amp;mid=2247495621&amp;idx=1&amp;sn=a851caf8d43f67d4438bdffee4cef348&amp;chksm=a7d5770a100a2308608e2c789a862bc9fd92aba08f7fa2a050a8eb43d5f443caedf04389522f&amp;scene=0&amp;xtrack=1#rd</link><description><![CDATA[想象你要在数字世界建造一座桥梁🌉——这座桥必须同时满足：✅ 双向可靠：确保数据能安全往返✅ 防御洪流：抵御网络延迟的"时光倒流"攻击✅ 密码同步：建立专属的数据传输暗号TCP三次握手正是这样的"桥梁建]]></description><author>everystep</author><pubDate>Sun, 23 Feb 2025 23:30:00 +0800</pubDate></item><item><title>如何根据业务场景选择Reactor/Proactor架构？</title><link>http://mp.weixin.qq.com/s?__biz=MjM5NjAxMzk4NA==&amp;mid=2247495605&amp;idx=1&amp;sn=596f88b9a034066a00935545964ec074&amp;chksm=a79b423c5153514a6c0b41aa24718e1c97a14b0ef350ab8984c068ce0e2228e0ff877f545535&amp;scene=0&amp;xtrack=1#rd</link><description><![CDATA[▌开篇灵魂拷问：当你网购时，是更喜欢快递柜自提还是外卖式上门？这两种服务模式背后，竟隐藏着服务器高并发设计的终极哲学！先看两个揪心场景：上班取快递📦：早高峰挤电梯到1楼，发现快递柜前已排起长龙（Rea]]></description><author>everystep</author><pubDate>Sat, 22 Feb 2025 23:54:38 +0800</pubDate></item><item><title>阻塞还是异步？看完这篇，你再也不用纠结 I/O 模型！</title><link>http://mp.weixin.qq.com/s?__biz=MjM5NjAxMzk4NA==&amp;mid=2247495552&amp;idx=1&amp;sn=59db5b8b00337a5e2adf27db277295fd&amp;chksm=a7fe6ef2f701ef3b6547f1ffcc9f16309f781f95c5de8d8f5690d207191ce0f939480b0d8b0a&amp;scene=0&amp;xtrack=1#rd</link><description><![CDATA[当你在键盘敲下回车时，数据开始内核态与用户态的穿梭 🖥️💫💾。I/O的本质是：用户程序 ↔ 内核缓冲 ↔ 硬件设备 的三层数据搬运。5种模型的核心差异在于——等待数据就绪的策略 🚦演化驱动力 🚀：阻塞]]></description><author>everystep</author><pubDate>Thu, 20 Feb 2025 07:00:00 +0800</pubDate></item></channel></rss>